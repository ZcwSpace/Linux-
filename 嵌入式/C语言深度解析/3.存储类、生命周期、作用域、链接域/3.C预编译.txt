
=====================================-===================================================================================
============================物联网、嵌入式技术课程 之 《C深度解析》======================================================
=========================================================================================================================

					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	


第3章：存储类、生命周期、作用域、链接域

1. 本章的意义：
		存储类、作用域、生命周期、链接域这几个概念并不是独立的，相互间有关联，而且这些概念又与好多
	的关键字有关，不少初学C的同学很容易拎不清，所以才有了本章，希望能够将这些问题讲清楚。
	
		本章的这些概念是C语言的核心概念，如果这些概念没有弄清楚的话，说明大家的C语言还有待提高。事实上本章
	的内容与第1章的《C编译、链接》的内容紧密相关，如果对第1章理解的还不错的话，其实本章很简单。

	
2. 本章知识点结构	
（1）回顾Linux下的c内存映像

（2）存储类与auto、static、register关键字
（3）指令、常量、变量的生命周期
（4）变量与函数的作用域
（5）链接域与extern、static关键字	
（6）声明的意义




课程内容：

1. 回顾Linux下c内存映像（内存结构）

		在第1章我们有详细的介绍过C程序在Linux下的内存映像，因为本章的课程需求，我们这里需要回顾一下。

		图1：
	
					
			
	1.1 代码段（只读段）
			代码段在编译时就定好了，在程序的运行过程中，不能在代码段开辟空间以及释放空间。
			
		1.1.1 ELF头、段头部表、init节
			这三个在第1章中已经介绍过了，在这里我们不再介绍。			・
			以后我们再介绍内存结构时，会直接将这三个节省略。
		
		
		1.1.2 .text
			指令节，也叫代码节，所有函数中的指令都放在了.text节中。
	
			能够与指令直接弄在一起的常量，也随指令一起放在了.text中。
				
			
		1.1.3 .rodata
			常量节，无法直接和指令放在一起的常量，就放在.rodata中。
			比如：char *p = "helloworld";
			
		

	1.2 数据段（可读/可写段）
	
		1.2.1 静态数据段
	
			（1）.bss
					未初始化的静态变量的空间，都开辟于.bss中。
			
			（2）.data
					初始化了的静态变量的空间，都开辟于.data。
	
				
			静态数据段的静态二字是什么意思？
			
				在.bss、.data中为哪些变量开辟空间，是由编译器在编译时决定的，在程序运行的过程中不能随意开辟，
			也不能随意释放已有变量的空间，像这种在编译阶段完成了变量空间安排的情况，就是静态的。

				
				比如：	
				int a = 100; //在.data中
				
				int main(void)
				{
					...
				}
				
				在程序的运行过程中，不能随意在.data中开辟一个全局变量空间，也不能释放已经开辟的空间，比如释放
			变量a的空间。
				
				
				
				
		1.2.2 动态数据段
		
				为什么称为动态的？
					变量空间的开辟和释放不是在编译阶段决定的，而是在程序的运行过程中完成的，这就是动态的含义。
				
			（1）堆（手动区）
						程序在运行的过程中，通过调用malloc函数来开辟空间，以及调用free来释放空间。
						
						之所以叫手动的，是因为我们在编写程序时，必须亲自调用malloc和free函数的代码。
						
						
			（2）栈（自动区）
					函数运行时自动从栈中开辟空间，函数运行结束时又会自动释放开辟的空间，开辟和释放的过程，完全是
				自动完成的。
					
					从栈里面开辟空间就是压栈，释放空间其实就是弹栈，压栈和弹栈的概念在第1章有详细介绍。
					
	
	
	
	
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
	
	
2. 存储类 与 static、auto、register关键字	
	
	
	2.1 什么是存储类？
			存储类这个东西，在不同书籍中可能解释得不太一样，在这里为了便于理解，我们会采用我们的解释方式。
		
			存储类的全称叫“存储类型”，存储类就是用来说明“常量、变量和函数”的存储位置的，比如自动局部变量在栈
		中，存储位置为栈，那么它的存储类就是栈。
	
	
	2.2 详细说说存储类，以及与之相关的auto、static、register等关键字
		
		2.2.1 函数指令
			存储类为.text，因为函数指令都是存放在.text中的。
			
			
			函数指令的存储类是固定的，所以函数指令的存储位置是固定不变的。
		
		
		2.2.2 常量
			（1）当常量比较小时
					小到能够和指令放在一起的话，就会和指令一起直接放在.text中。
					
					此时常量的存储类为.text。
					
					
			（2）常量比较大时
					大到无法直接成为指令放在一部分，此时就需要单独的存在.rodata中，此时常量的存储类就为.rodata
				
			
			常量的存储类也是固定的，要么是.text，要么是.rodata。
					
					
		2.2.1 全局变量
			（1）初始化了的全局变量
					存储类为.data。
			
			（2）未初始化的全局变量
					存储类为.bss
			
				全局变量的存储类也是固定的，要么在.data中要么在.bss，.data、.bss合称为静态数据段，或者静态数据区，
			所以全局变量的存储类可统称为“静态数据段”。
				
				
				
		2.2.2 局部变量
				局部变量的存储类不是固定，根据修饰的auto、static、register关键字的不同，存储类不同。
					
			（1）自动局部变量 与 auto关键字
					fun()
					{
						auto int a; //等价于int a，auto可以省略不写
					}
					
					1）auto
							为局部变量的存储类关键字，auto只对局部变量有效。
							如果不写auto的话，默认就是auto的，所以我们平常定义的局部变量，默认都是auto修饰的。
					
					2）auto所对应的存储类
							auto就是automatic自动的意思，以auto int a为例，auto就表示a的空间是自动开辟、自动释放的，
						我们知道只有栈才满足自动开辟自动释放的特点，因此auto就表示a的存储类为“栈”。
								
							正因为自动开辟、自动释放的特点，auto修饰的局部变量，我们就称为“自动局部变量”。
							
					2）疑问：怎么感觉auto这个关键字是多余的？	
							auto这个关键字对于我们程序员来说确实是多余的，既然auto可以省略，那我们就不会傻到去把auto
						写上，auto在C程序中几乎看不到，因为没有哪个程序员是傻子。
						
							其实这个auto关键字主要是给编译器用的，因为编译器必须通过这个关键字来识别“栈”这个存
						储类，就算auto被省略了，但是在编译时会被自动加，用以标记局部变量是“栈”这种存储类。
						
						
			（2）静态局部变量 与 staitc关键字
					fun()
					{
						static int a=100; //static不能省，省了就默认是自动局部变量
						static int b;     //未初始化的静态局部变量
					}
					
					
					1）static
							static有两种用法，
							第一种：修饰局部变量
								当static修饰局部变量时，static用于标记局部变量的存储类。
							
							第二种：修饰函数和全局变量
								与链接域有关，这个后面再介绍。
								
								
						
					2）static对应的存储类

						（a）初始化了的静态局部变量，存储类为.data
								比如例子中的a就被初始化了，所以a的存储类为.data。
								
								
						（b）未初始化的静态局部变量，在.bss中
								比如例子中的b就没有被初始化，所以b的存储类为.bss。
										
						.data和.bss合称为静态数据段，所以静态局部变量的存储类合称为静态数据段。

						
					3）静态变量
							由于全局变量与静态局部变量的存储类都是静态数据段，因此我们就将全局变量和静态局部变量
						统称为静态变量。
							
							
							
							
			（3）寄存器局部变量 与 register关键字
					int fun()
					{
						register int a=100; //register不能省略，省略了就变为了默认的自动局部变量
	
					}
									
					1）回顾CPU对存储器的访问
							
									     寄      1         2                 内      外（磁盘）
							cpu <――> 存 <――> 级  <――>  级  <――> ... <――>    <――>   （sd卡）
									     器     cache     cache              存      存（固态硬盘等）
					
					
							・ 存储容量
									寄存器  < 1级cache < 2级cache < ... < 内存 < 外存
							
							・ CPU访问时的访问速度
									寄存器>1级cache > 2级cache > ... > 内存 > 外存
								
								以上情况，是由各存储器的材质和制作工艺来决定的。
								有关以上的内容，我们在《计算机体系结构――硬件篇4》存储器的课程有详细介绍。
	
	
					2）register
							register为寄存器的意思。
							使用register修饰局部变量后，局部变量的存储类就为寄存器，也就是说此时局部变量的空
						间开辟于寄存器中。
							
							register修饰的局部变量，我们就称为寄存器局部变量。
							
							
					2）将局部变量的存储类设为register有什么好处？
							由前面的介绍可知，cpu访问寄存器的速度 远远> 访问内存的速度，所以如果你希望cpu能够更快速的
						访问局部变量的话，我们就可以使用register修饰，让局部变量的空间在寄存器中。
							
							例子：
							
							a.c
								#include <stdio.h>
								#include <time.h> 			//time函数所需的头文件

								int main(void)
								{
									register int a = 0; 	//寄存器局部变量
									int b = 0; 						//自动局部变量(栈)
									int old_time = 0; 
									
									old_time = time(NULL);				//记录循环开始时的时刻

									for(a=0; a<1000000000; a++); 	//循环累加a的值，实现延时

									printf("%ld\n", time(NULL)-old_time); //延时时间 = 结束时刻-其实时刻


									old_time = time(NULL); 				//起始时刻

									for(b=0; b<1000000000; b++); 	//延时

									printf("%ld\n", time(NULL)-old_time); //延时时间

									return 0;
								}
								运行结果：
								0
								3
								
								a：寄存器局部变量
								b：栈中的自动局变量
								
								cpu访问a速度 > 访问b的速度，不过由于时间差太小了，很难感受到，但是就像我们所举的例子
							一样，当对a和b的访问次数到达一定数量级时，访问a和b的速度差还是可以被明显的感受到。
							
								
					2）什么时候可以使用“寄存器局部变量”？
						（a）如果某个局部变量的访问速度要求很高的，我们就可以使用regster来修饰。
								
						（b）如果程序中某个局部变量的使用频次非常高，此时为了提高访问效率，我们也可以使用register修饰。
								
								比如我们后面讲uboot移植时，uboot中使用频次比较高的局部变量，有些就会被register修饰。
							
							
					3）register令人糊涂的地方
					
						1）第一个令人糊涂的地方：虽然写了register，但不一定有效。
								如果cpu的寄存器数量很少，比如intel cpu的寄存器数量相对ARM CPU来说就偏少，所以很有可能
							出现寄存器不够用的情况，如果编译器编译时发现寄存器不够用了，编译器就会将register自动改
							为auto。
								
								说白了就是虽然是register修饰的，但是最终能不能起作用不一定，看编译器。
						
						
						2）第二个令人糊涂的地方
								就算你不写register，以优化方式编译时，编译器也可能会帮你自动改为register，这里说的是
							可能会。
								
								比如上面的例子a.c，我们gcc优化编译，
									gcc a.c -O1  //优化级别>=O1就行
							
								优化编译后你会发现，延时的时间几乎是一样的，说明b的存储类被编译器从auto改为了register。
								
								
								疑问：老师你怎么这么肯定？
									如果你想确定b到底有没有被改为register，查看汇编是最直接的办法，我已经查看过，
								b的空间确实开辟于寄存器，而不是栈，那就说明b的存储类确实被改为了寄存器。
								
								
								疑问：优化编译时，为什么b会从auto变为register？
									我们给了编译器优化权限，当编译器觉得代码不够好时，就会进行优化。
									
									gcc优化编译例子程序a.c时，编译器发现b的使用频次非常高，觉得很影响效率，所以编译器就将b
								的存储类从auto自动改为了register。
								
									不过编译器也不是一定会优化为register，因为如果编译器发现寄存器数量不足的话，此时b的存储
								类就还是auto。
								
									优化有好处，自然也有缺点，最大的缺点就是自作主张修改你的代码，让原有的代码逻辑发生
								改变，甚至有时完全违背了你的原意，所以如果你不想被优化的话，建议编译时就不要指定优化选项。
								
									有关优化，第9章还会介绍。
								

					4）我们应该如何对待register？
						（1）明白它的用途
									如果你在别人的代码中看到了这个关键字，你要明白这是什么意思。
								
						（2）在我们自己的程序中，不建议使用
									因为这个关键字并不能一定管用，到底管不管用取决于编译器的处理，带有不确定性，因此
								我们建议不使用，而且现在确实也用得少了。
				
				
								
		2.2.2 形参								
				一般情况下形参的默认存储类为栈，所以形参空间默认就是开辟于栈中。
				
			（1）auto、static能不能修饰形参？
					不能，这两个关键字不能用于修饰形参，对于形参来说默认的存储类就是栈，不需要auto来说明。
				
				
			（2）register能不能修饰形参？
					可以，此时存储类为寄存器，所以形参的存储类就两种：
					
					默认：栈
					register修饰：寄存器。
				
				
			（3）ARM下的一个特殊情况
			
						ARM cpu的寄存器特别丰富，为了能够提高效率，编译器在编译针对ARM的c程序时，如果函数的形参小于
					4个的话，形参的存储类默认会定为register。
						
						只有当形参数量超过5个时，第5个以后的形参的存储类才默认为栈，如果第5个以后的形参的存储类被指定为register，那么存储类还是register。

						如果编译器编译的是针对Intel CPU的程序的话，由于Intel cpu的寄存器数量相对比较少，所以函数形参的
					存储类默认都是栈；如果在程序中人为指定为register的话，存储类有可能会是寄存器。

					
		
		2.3.3 能否使用auto、static、register修饰全局变量？
		
			（1）auto和register
						全局变量的存储类是固定的，为静态数据区，如果使用auto和register修饰全局变量的话，其实是在
					尝试使用auto和register将全局变量的存储类改为栈和寄存器，显然这是不行的，这会导致编译出错。
				
				
			（2）staitc
						可以，使用static修饰全局变量时，static与存储类半毛钱关系都没有，static修饰全局变
					量时只与与链接域有关，后面讲到链接域时再来介绍。
			
			
			
			
	
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
			
3. 指令、常量、变量的生命周期
		
	3.1 什么是生命周期？ 
		生命周期，指的就是空间从诞生到消亡。
			
		诞生：从内存中开辟出空间。
		
		消亡：释放空间
		
		只有在生命周期这段时间内，空间才是有效的，在生命周期外的时间，空间是无效的，不能访问。

			
	3.2 指令和常量的生命周期
		指令在.text中，常量要么在.text中，要么在.rodata中。
		
		指令和常量的生命周期为整个程序运行期间，
		
		疑问：为什么指令和常量的生命周期是整个程序运行期间？
		
			就以指令为例来解释这个问题，假如在.text中，某些指令所占空间的生命周期不是整个程序运行期间的话，
		这就麻烦了，当程序运行到某个时间点需要调用某个函数时，结果函数指令所在空间因为生命周期到了而被
		释放了，调用这个函数时就会调用失败，整个程序运行出错。

		
	3.3 .data、.bss变量的生命周期
			全局变量和静态局部变量的存储类为.data或者.bss，所以.data、.bss变量指的就是全局变量和静态局
		部变量，.data、.bss变量的生命周期也为整个程序运行期间。
		
		
			也就是说程序一开始运行时变量空间就存在，直到到整个程序运行结束.data和.bss被释放时，
		.data和.bss中的全局变量和静态局部变量才会被释放。
			
		
			为什么.data、.bss变量的生命周期也为整个程序运行期间？
				以全局变量为例，全局变量是所有函数共享操作的变量，如果运行到某个时刻被释放了，也就是生命周
			期到了，这也扯淡了，这会导致某个正在使用该全局变量的函数出现严重错误。
			
			
		例子：
			
			int i = 0; //i一直有效，直到程序运行结束。
			
			int fun()
			{
				static int fnum = 0; //fnum一直有效，直到程序结束，每次调用fun函数时，累加的都是同一个fnum。
				printf("%d\n", fnum++);
			}
			
			int main(void)
			{
	
				for(i=0; i<5; i++)
				{
					fun();
				}
			}
				
				
	3.4 栈变量的生命周期				
			形参和自动局部变量的存储类为栈，所以栈变量指的就是形参和自动局部变量。
		
			在第1章就讲过，定义形参和自动局部变量的代码，编译后会变成代码块的压栈、弹栈指令。
		
			我们写一个伪代码
		
													  伪代码
			int fun(int a)         编译后              fun
			{                                          {
				int b;                                   	push a //压栈，从栈中给a开辟空间 
				...                                         push b //压栈
															...				
																										
				if(a>100)                                   if
				{                                           {
					int c;                                    	push c //压栈
					...                                         ...
																pop c  //弹栈
				}											}
																										
															pop b  //弹栈，释从栈中开辟的空间b
															pop a  //弹栈，先压栈的后弹栈
			}											}
		
			栈变量的生命周期 = 从push指令开辟空间 到 pop指令释放空间 期间。
			
			代码块开始运行时执行push，代码块运行结束时执行pop，因此栈变量的生命周期 约等于 代码块的生命周期。
			
			例子：
			
			int fun(int a)    			//a生命周期：代码块fun的生命周期
			{
				int b;          			//b生命周期：代码块fun的生命周期
			
				if(a > 100)     			
				{
					int c;             	//c生命周期：代码块if的生命周期
					
					c = a + b;
				}
					
				{                     
					int d;              //d生命周期：代码块的生命周期
					
					d = 2*c;
				}
			}

			疑问：register变量的生命周期？
			认为与栈变量相同。


			
				
	3.5 堆变量的生命周期
		malloc成功后，堆变量的生命周期开始，调用free将空间释放后，生命周期结束。
		
		所以堆变量的生命周期 == malloc 到 free之间的时间。
		
		疑问：如果忘了free怎么办呢？
			程序运行结束时整个堆会释放，堆中忘了free的堆变量空间自然也会被释放，但是一定要在程序运行时就free，
		不要等到程序运行结束再释放，至于为什么要这样，在第1章有详细解释。
			
			
				
				
				
				
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
					
					
4. 变量和函数的作用域
	
	4.1 什么作用域
		就是变量和函数起作用的范围，只要在这个范围内，你就可以访问该变量和函数
		
		作用域实际上有三种：
		（1）局部变量的代码块作用域
		（2）函数和全局变量的本文件作用域
		
		（3）跨文件作用域 ―― 链接域，与链接有关
			
		前两种我们在本小节介绍，第三种我们放到“链接域”小节介绍。
		
		
	4.2 局部变量的代码模块作用域
				
		（1）什么是代码块
				其实有关代码块，我们在讲生命周期时就提到过。
				
				那什么是代码块呢？
				简单理解就是{}括起来的就是代码块，不要把代码块等价为函数，因为if、for、while等同样有{}这个东西。
				
					
		（2）代码块作用域 的 范围
				从定义处到代码块结束。
		
		
		（3）例子
			
					int main(void)
					{
						int a; //a的代码块作用域：从定义位置开始到main函数的}。
						
						{
							int b; //b的代码块作用域：定义位置开始到内部}。
							...
						}
						
						...
					}
					
					int b所在的内部{}实际上才是真正的代码块，只不过在广义上我们将所有带{}的都理解为代码块，当然
				结构体类型定义除外，虽然结构体类型的定义有{}，但不是代码块。
					struct student
					{   					//这个不是代码块
						int num;
						...
					};
					
					
				疑问：代码块有什么意义？
				后面第9章再介绍。
			
			
		（3）形参的作用域
				形参的作用域也是代码块作用域，不过有些特殊的地方需要说明下。
				我们直接举例介绍。
				
				int fun(int n, int buf[][n]) 
				{
					...
				}
							
				int main(void)
				{
					int buf[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
						
					fun(4, buf);
					
				}	
				

				n的作用域：定义位置开始，到参数列表末尾，再到fun的}
				buf[][n]的作用域：定义位置开始，到参数列表末尾，再到fun的}
				
				由于n的作用域覆盖了buf，所以才能在buf中使用n，如果反过来的话fun(int buf[][n]，int n)，编译时
			会提示buf中的n无法识别，因为buf不在n的作用域内。
				
				
				
					
	4.2 函数和全局变量的本文件作用域				
			
		4.2.1 本文件作用域的有效范围
		
			从定义位置开始到文件结束。
			
			a.c
				int main(void)           	//main的本文件作用域：从定义位置到文件末尾
				{
					fun(g_var1, g_var2);
					
					return 0;
				}
				
				int g_var1 = 100;    		 	//g_var的本文件作用域：从定义位置到文件末尾
				int g_var2;
				
				int fun(int a)        		//fun的本文件作用域：从定义位置到文件末尾
				{
					int var;            		
					
					return var +a;
				}
			
			
		4.3.3 通过声明改变本文件作用域
			在上面的例子中，如果我们想在main函数中使用g_var1、g_var2、fun的话怎么办？
			
			
		（1）方法1
				挪到main的前面去。
				
		（2）方法2
				在main前面进行声明，通过声明将作用域提前。	
				
				a.c
					int g_var1;  
					int g_var1; 
					int g_var1; 
					int g_var1; 
					
					int g_var2;
					int g_var2;
					int g_var2;

					
					int fun(int a);
					
					
					int main(void)           
					{
						fun(g_var1, g_var2);
					}
					
					int g_var1 = 100;    				
					int g_var2;
					
					int fun(int a)        		
					{
						int var;            	
						
						return var +a;
					}
					
					
		（3）定义与声明的关系
					定义与声明的关系，其实就是第1章中介绍的“强弱符号关系”。
				
					我们知道，定义与声明的符号名是相同的，编译时同名符号必须进行统一，然后合并为一个。
					在第1章中，我们详细介绍过强弱符号的统一规则，我们这里再回顾下。
					
					
				1）谁是强符号，谁是弱符号
					・ 函数定义：强符号
					・ 函数声明：弱符号
				
					・ 初始化了的全局变量：强符号，我们常将这种称为定义
					・ 未初始化的全局变量：弱符号，我们常将这种称为声明
				
				
				2）强弱符号的统一规则
				
					（a）不能允许重复出现同名的强符号，但是允许重复出现有同名的弱符号
							
							・ 在a.c中同时定义两个全局变量int a = 100，编译无法通过。
							
							・ 在a.c中同时定义两个同名函数fun，也编译无法通过
							
							・ 可以对全局变量和函数进行重复声明，因为声明是弱符号，允许同名弱符号重复
						
								以前学C时老师总是讲，声明可以重复，原因就来自于这里。
						
							
					（b）有一个强符号，其它都是弱符号的话，只保留强符号，其它弱符号消失
					
								同名符号的作用域以最前面的那个符号为准，正是因为这点原因，放在最前面的声明才能提前作用域。		
							所以声明虽然是弱符号，遇到强符号时消失了，但是它能够提前作用域。
						
									
									
					（c）全都是弱符号的话，只留一个即可，其它全部消失
								比如a.c中的两个int g_var2都是弱符号，统一符号时只留其中一个，留哪一个由编译器决定。
							但是不管留哪一个，作用域范围以最前面的哪一个为准。
								
								同一个.c中的强弱符号统一，是在第二阶段编译时由编译器来完成的，而不同.c中的强弱符号
							统一，则是由第4阶段“链接”来完成的，这一点我们在第1章详细介绍过，后面介绍“链接域”时，还会
							再次讲到。
							
							
				
							
		（4）声明全局变量的特殊例子	
					int g_var1;
					
					int main(void)           
					{
						extern int g_var1; //声明  
						
						g_var1 = 100;
					}
					
					int fun(int a)        		
					{
						int var;            		
						
						return var +a;
					}
					
						
					int g_var1 = 100;    		
					
					
					main函数中extern int g_var1这种的生命方式表示，g_var1只在main函数内有效，对后面的fun无效。
					
					extern可以省略吗？
						不能省，省了g_var1就变成main的自动局部变量了，extern表示这个全局变量来自于函数外部。
					extern有好些用法，不同用法的含义不一样，在这里先了解下这种用法。
						
						假如你只想在main中使用g_var1，不想让g_var1的作用域覆盖到fun函数，就可以使用这种方法，不过这
					种声明方式用的确实不多，但是在有些源码中可能会看见，这里需要了解下。
				
				
					同样的，函数也可以进行类似的声明。
								
					int main(void)           
					{
						extern int fun(int a); //fun的声明。
						
						fun(g_var1, g_var2);
					}
					
					int fun(int a)        		
					{
						int var;            		
						
						return var +a;
					} 
				
				
				
		（5）局部变量有声明吗？
					局部变量没有声明一说，以下做法时错误的。
					
					int main(void)
					{
						int a; //声明：错误用法
						
						a = a + 1;
						
						int a = 100;
					}
					
					说白了就是，对于局部变量来说，变量符号只能有一个，不允许同名符号重复出现。
					
					
		（b）同一个.c中，变量同名的问题
		
				1）全局变量
					（a）如果同名变量都是强符号，这会导致变量重复定义，编译时会报错。
					
					（b）如果同名的是弱符号，它只会改变符号的作用域，除此外没有影响
					
					
				2）局部变量
					不允许存在同名符号。
					



				
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
									
					
5. 链接域	与 extern、static关键字
	
	
	5.1 回顾链接
	
			我们在第1章详细的讲过链接，这里因为课程的需求，我们需要再回顾下。
			
			一个真正的C工程一定是多文件的（多.c、多.h），这些文件被编译为.o后，需要被链接为一个完整的可执行
		文件，链接的工作由链接器来完成。
				
			链接时主要做两件事：
			（1）符号解析
					1）对全局符号进行符号统一
					2）将符号的引用 与 符号的定义关联起来
						
			（2）地址重定位
					
					
			本小节的要讲“链接域”其实就与链接时的“全局符号统一”有关。
		
		
		
	5.2 链接域 ―――― 跨文件作用域
	
		5.1 回顾 代码块作用域
				形参和局部变量的作用域就是代码块作用域，对于形参和局部变量来说，不允许出现同名符号，所以不
			存在需要统一同名符号的情况。
				
				而且代码块作用域只局限在代码块内，与其它文件没有任何关系，所以与链接无关。
			
			
		5.2 回顾 本文件作用域
				在单个.c中，全局变量和函数的作用域就是本文件作用域，由于允许对全局变量和函数进行声明，所以在单
			个.c中存在同名符号的问题，编译时需要进行同名符号的统一，统一规则就是强弱符号的统一规则。
				
				由于本文件作用域只与当前文件有关，与其它文件无关，因此也与链接无关。
	
	
		5.3 跨文件作用域 与 extern关键字
		
			5.3.1 为什么需要跨文件作用域
			
					对于全局变量和函数来说，有时不仅仅只希望在本文件可以被使用，还希望在其它的文件中也能被使用，
				此时作用域就必须跨越到其它文件中，这就所谓的涉及跨文件作用域。跨文件作用域说白了就是将作用域
				延伸到到其它文件中。
				
					跨文件作用域涉及到多个文件，由于多文件最后要被链接到一起，与链接有关，所以我们也将跨文件
				作用域称为链接域。
				
				
	
			（1）如何实现跨文件的作用域
					只要满足两个条件即可。
			
					1）将定义标记为extern
						extern表示定义的符号是一个全局符号，由于是全局符号，因此对于其它文件来说这个符号是可见的。
						
						
					2）在其它文件中进行声明，声明也需要标记为extern
						extern表示声明的符号也是一个全局符号，对于其它文件也是可见的。
						
						
					正式因为extern将符号标记为了全局可见，在链接阶段才能对全局符号进行“符号统一”。
						
						
			（2）例子
					a.c                            	b.c
					
					extern int a;                   int a = 100; //全局符号，extern可以省略
					extern int fun();								
					int main(void)                  int fun()
					{                               {
																						printf("helloworld\n");
						                        
					}                               }
					
					
					extern可以省略，省略后默认就是extern的，与auto有点像。
					
					对于几乎所有的编译器来说，都认可在定义时将extern省略，但是对于声明来说，有些编译其允许省略extern，
				但是有些就不允许，我们目前使用的gcc就允许声明时省略extern。
				
					不过为了保证不出错，经常的做法是，定义时省略extern，但是声明时必须保留extern。	
					
					由于全局符号的定义和声明是同名的，所以在链接阶段需要按照强弱符号的统一规则，对全局符号进行
				统一，声明作为弱符号最后会消失，虽然消失了，但是它却将“作用域跨”拓展到了其它文件中。
						
					从这里可以看出，想要实现跨文件作用域的话，必须使用声明这个弱符号来拓展作用域。
					
					
				不过有一点需要注意，我们说全局变量和全局符号时，这两个全局的意思不相同。
				・ 全局变量的“全局”：指的是文件
				・ 全局符号的“全局”：指的是整个C工程项目
				
				
				
	5.3 全局符号的重名问题 与 static关键字			
		
		（1）全局符号的重名问题	
		
				extern所修饰的符号是所有文件都可见的全局符号。

				如果在不同文件中存在同名强符号的话，全局符号符号统一时就会报错，但是大家要知道一旦C工程变得
			复杂之后，在不同的文件中，误定义同名的函数和全局变量的情况是无法避免的。
			
				为了避免同名全局强符号的错误，我们应该尽量使用static关键字来避免这个问题。
			

		（2）static修饰函数和全局变量时的作用
					将符号标记为本地符号。
					
					
				1）什么是本地符号？
						我们在第1章中详细介绍过，这里再简单回顾下。
					
						所谓本地符号，就是符号只在本文件内可见，其它文件不可见，链接阶段进行全局符号统一时，所有
					static修饰的本地符号在全局是不可见的，所以不参与链接阶段的符号统一，因此就算同名了也不会报错。
				
				
				
				2）本地符号的作用域
				
						static将符号变为本地符号，说白了就是关闭符号的链接域，或者说关闭符号的跨文件作用域，
					符号此时只剩下“本文件作用域”。
				
						为了最大化的防止重名问题，建议凡事只在本文件起作用，而其它文件根本用不到的函数和全局变量，
					统统使用static修饰，让符号在全局不可见，防止全局强符号的同名冲突。
				
						C中使用static来解决全局强符号的命名冲突，其实是非黑即白的解决方式，为了能够更加精细化的解决
					命名冲突问题，从c扩展得到c++时，C++引入了命名空间这一概念，当然这个就是属于C++的内容。
					
					
					
		
				
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
						
	5.4 总结一下extern 和 static关键字					
		本章我们介绍了不少的关键字，其中extern和static的用法稍微凌乱些，所以总结下。
		
		（1）static
				1）修饰局部变量
						与存储类有关，表示局部变量的存储类为静态数据段。
				
				2）修饰全局变量
						与存储类无关，因为全局变量的存储类本来就是固定的静态数据段。
						
						static修饰全局变量，表示符号为本地符号，关闭链接域（跨文件作用域），让其在全局不可见。
						
				
				3）修饰函数
						与修饰全局变量是一样的，将符号变为本地符号，关闭链接域，让其全局不可见。
						
						
						
						
		（2）extern
				1）修饰函数、全局变量的定义和声明时
						表示符号是全局符号，将链接域（跨文件作用域）被打开，让其全局可见。
					
				
				2）将函数体外的全局变量和函数，声明到函数内部
					a.c 
						
					
						int main(void)
						{
							extern int a;
							extern int fun();
							
							a = a+1;
							fun();
						}
						
						int a;
						int fun()
						{
							
						}
					
						此时fun函数也可以在其它的.c中，此时涉及到的就跨文件作用域。
				


				
6. 声明的作用
	
	6.1 变量的声明
			拓宽变量的作用域。
			
			如果没有通过声明来拓宽变量作用域的话，在第二阶段编译时，编译器就会提示你所使用的某个符号找不到，
		有了声明后，其实就是告诉编译器，你所使用的这符号是由定义，不要报错。
			
			
	6.2 函数的声明
	（1）拓宽函数的作用域
			
			
	（2）进行形参、返回值的类型检查
	
			1）如果函数的定义位置在调用位置之前时
					此时函数定义本身就是一个函数声明，无需额外的声明。
					
					编译阶段进行函数的类型检查时，直接通过函数定义来进行类型检查。
					
					
			2）如果函数定义的位置不在调用位置之前
					如果不进行声明的话，编译时是不会进行类型检查的，所以我们必须进行声明，声明后再进行编译时，
				就会通过声明来进行函数的类型检查。
			
	
			
			
			3）类型检查有什么用
					类型检查其实很有用，进行类型检查时如果发现类型有问题的话，编译时打印提示信息，这样可以帮
				助我们更好的排查函数错误。
			
				例子：		
					int main(void)
					{
						int a = 10;
						
						fun(100);
						
						return 0;
					}
					
					int fun(int *p)
					{
						
					}
					
				1）如果没有声明
					只报函数没有声明的警告。
					
					尽管实参和形参类型明显不匹配，但是编译器并没有提示“类型有问题”，因为没有做类型检查。
					
					
				2）如果加上声明
						编译时就会通过声明进行类型的检查，然后报实参和形参类型不匹配的警告，这个信息可以帮助我们
					排查函数的类型错误。

			
	（3）不进行函数声明，编译可以通过吗？
				
				如果函数定义本来就在函数调用位置的前面，定义本身就是声明，编译肯定能过。
			
				但是如果函数定义不在调用位置的前面，而且还没有给额外的声明，编译还能过吗？
				
				这要看编译器的严格程度，有可能编译通过，但是有些严格编译器编译时不能通过。
				
				不过不管人家编译器严不严格，按照正规操作，我们必须要进行声明，如果不进行声明的话，编译时不会
			进行函数的类型检查，由于没有做类型检查，就算程序能够编译通过，而且还能运行，但是很有可能会出现
			因传参和返回值类型不对而导致的错误。
			
	
	
	（4）调用库函数为什么需要进行声明

			比如在程序中调用printf时，必须在.c中包含stdio.h头文件，因为这里面有printf函数的声明。
			
			对库函数进行声明，函数声明的目的是一样的。
	
			一是为了拓展作用域，二是为了进行参数检查，与我们前面所举例子的唯一不同是，库函数时别人帮我们写好。
			
			
			如果调用的函数不在本文件中，而在其它的文件中，比如
			・ 在我自己写的其它.c中
			・ 在库文件中
			
				除了要对函数进行声明外，还必须链接函数所在的文件，函数声明的只用于“作用域的拓展”和类型检查，
			第四阶段链接时，必须要链接函数所在的文件。
				
				
				只有在链接了函数所在文件后，在链阶段进行声明和定义的全局符号统一时，你才能在链接文件
			中找到全局函数的定义，不然链接时会报该函数没有定义的错误。
		
						a.c    
						extern fun();
						
						int main()
						{
							fun();
						}

						b.c 
						int fun()
						{

						}						
			
						gcc a.c 
						
						
		
		
		
