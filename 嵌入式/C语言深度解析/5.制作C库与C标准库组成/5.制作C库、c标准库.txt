
=====================================-==============================================================================
============================物联网、嵌入式技术课程 之 《C深度解析》========================================
====================================================================================================================
					
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------

第5章 制作c库 和 了解c标准库
	对于c这种面向过程的语言来说，使用的函数库，而对于java这种面向对象的语言来说，使用的则是类库。
	对于c开发来说，“c函数库”是非常重要的组成，所以我们有必要知道如何制作一个c函数库，以及了解“c标准库”的
基本组成。

本章目录：
1. 如何重复利用常用函数的代码
2. 库的原理
3. 库文件的尾缀
4. 静态库基本介绍
5. 动态库基本介绍		
6. 比较动态库与静态库
7. 实现库的难点
8. 制作、使用静态库和动态库
	8.1 制作和使用的基本方法
	8.2 Linux命令行方式 
		8.2.1 制作、使用静态库
		8.2.2 制作、使用动态库
	8.3 IDE方式
		8.3.1 制作并使用静态库
		8.3.2 制作并使用动态库
		
		有同学曾经问dlopen函数的作用，讲动态库的制作和使用时，就会介绍这个函数的作用。
		
		
10. c库函数与OS API的关系
11. c标准库
	11.1 c标准
	11.2 c标准库的基本组成
	
	
1. 如何重复利用常用函数的代码？
	在早期的开发中人们就开始意识到，有些函数代码是会被经常重复用到的，比如：
	・ 做“平方”、“开方”等数学函数
	・ printf、scanf等人机交互函数
	・ 等等
		
		如果每一次编写程序时，都重新实现这些函数的话，显然会非常麻烦，不利于提高编程的效率，所以必须想办法
	提高常用函数代码的重复利用率，以提高开发效率。
		函数代码的复用方式有如下几种：
	・ 以源码形式复用
	・ 以.o文件复用
	・ 以库形式复用	
		
	
1.1 以源码形式复用 
1.1.1 如何复用？
	在自己的程序中，需要调用到什么函数，就将函数源码所在的.c、.h拷贝到自己c工程中，然后和自己的程序的.c、.h
一起编译，然后得到可执行程序。
	对于编译器来说，不管是自己写的代码，还是复用的源码，都是一样的，并没有区别，只不过复用的源码不一定是
我们自己写的。

		          预编译、编译、汇编
		fuyong1.c --------------------> fuyong1.o―\
		...       										  ...        \
		fuyongn.c --------------------> fuyongn.o --\  链接
		                                            /――――――――――> 可执行程序（a.exe/a.out）
		self1.c   --------------------> self1.o----/
		...                             ...       /
		selfn.c   --------------------> selfn.o――/
		
		
		为了画图的方便，图中没有写出.h文件。
		
		有关c程序编链接的详细过程，我们在第1章中有详细介绍，不清楚的同学请学习第一章。
		
		
1.1.2 源码复用的缺点：
	以源码形式复用情况并不少见，以源码形式复用时，我们可以将源码直接称为“源码库”，当然源码有源码的好处，
好处就是，你可以通过源码了解代码的具体实现，但是源码的缺点也是明显的。
	
	使用源码有三个缺点：
（1）缺点1：“源码可见”不利于版权保护
（2）缺点2：我们自己要清楚，我们要使用的函数在哪个.c中，但是如果源码中.c、.h非常多的话，这就有些麻烦了。
（3）缺点3：编译c源码很耗费时间
		很多同学对于这一点可能感受可能不深，其实如果程序的代码量非常庞大的话，这是非常耗费编译时间的，
	本来当一个程序写大之后，就已经要耗费不少的编译时间了，如果再加入大量的源码在里面，这将会更加的拉长
	编译时间。
	
	正是因为以上原因，所以源码库虽然并不多见，但是也不少见，比如stm32单片机的标准外设库和HAL外设库，
就是以源码形式提供的，但凡提供源码，必然是开源的。

	公开源码也不见得就不好，就看公司自己怎么定位，stm32的公司之所以公开源码也是出于商业角度来考虑的，这样
的话可以更好的培养客户粘度，更有利stm32芯片的售卖。
	
	
1.2 以二进制.o文件复用
1.1.2 如何复用？
	事先将要被复用的.c全部编译为对应的.o， 
	
						   预编译、编译、汇编
		fuyong1.c --------------------> fuyong1.o  （.o二进制文件）
		...       										  ...        
		fuyongn.c --------------------> fuyongn.o 
	
	
	你要调用什么函数，就将这个函数所在的.o复制到自己的工程中，然后与自己程序的.o链接到一起，就得到了可执
行程序。
	
																		fuyong1.o-\
																		...        \
																		fuyongn.o --\  链接
		           预编译、编译、汇编               /――――――――――> 可执行程序（a.exe/a.out）
		self1.c   --------------------> self1.o----/
		...                             ...       /
		selfn.c   --------------------> selfn.o -/
		
		
1.2.3 优点：
		这种方式的有点很明显：
（1）.o为二进制文件，文本编辑器是无法正常显示二进制文件的，打开后为一堆的乱码，提供.o的话，可以有效的避
			免了源码外泄的问题。
			
（2）要复用的源码，事先早就被编译为了.o，只需要链接即可，有效的节省了编译时间。
		
		
1.2.4 缺点：
	当要复用的.o非常多时，比如有几十个、甚至几百个时，要记住那些函数在那些.o中的话，其实是很困难的事情。
	基于这样的原因，大家就想着能不能自动识别呢，比如我在程序中调用到了什么函数，就自动去识别这个函数在哪
个或者那几个.o中，然后自动去链接这些.o，于是就有了真正意义上的“函数库”。
	
	真正的“库”其实就是就是将.o进行打包，做成库文件，链接库时，库会自动识别我们程序中调用的函数在哪些.o中，
然后自动找到那些.o，然链接到我们的程序中。


2. 库的原理：
	原理很简单，先将要复用的源码.c编译为对应的.o，然后再将所有的.o打包做成“库”文件。
			fuyong1.c --------------------> fuyong1.o--\  “打包”
			...       										  ...         >―――――――> 库文件
			fuyongn.c --------------------> fuyongn.o--/ 
	
	
	使用时，直接链接“库文件”即可，在程序中调用了某个函数，链接库文件时会自动帮我搜索这个函数在库中的
哪些.o中，然后就链接库中这些.o。

	做成真正的库文件有如下好处：
	1）不需要公开源码，维护了版权
	2）不需要浪费额外的编译时间，因为事先就编译好了，只需要链接即可。
	3）也不需要人为的挑选.o，链接库时会自动的搜索。
				
3. 库文件的尾缀：
	库分为两种，静态库 和 动态库。
	静态库和动态库文件的尾缀，与编译器和操作系统都有关。
	
3.1 静态库：
	总的来说，静态库的尾缀是由平台来决定的
	・ windows平台：静态库的结尾为.lib 
		
	・ Linux平台：静态库的结尾为.a 
	
	但实际上静态库文件是以.a结尾还是.lib结尾，与编译器也有关，比如gcc编译器，不管编译得到静态库是运行在
windows上还是运行在linux上，使用gcc做出的静态库文件都是以.a结尾的。
	
	
3.2 动态库 
	动态库名字的尾缀，基本上只与平台有关，
	
	・ windows平台：动态库的结尾为.dll
	・ Linux平台：动态库的结尾为.so

	
	
	
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------
	
4. 静态库的基本介绍
4.1 如何得到静态库？
	比如得到数学库。
	先编译源码得到.o，然后再将所有的.o打包为“静态库文件（libmath.a）”。
	
	图：
	
	
	
4.2 如何使用静态库	？
	比如我写了一个c程序，里面调用到了“开方”数学函数，假设开方函数在libmath.a的kf.o中。
	
	图1：
	
	
	
	链接时，直接将kf.o中代码链接到自己的程序中。
	
	“静态库”只是对所有的.o进行了打包，在连接库中.o文件，与链接一般的.o文件没有任何区别。
	
	
4.3 为什么称为静态库？	
	静态库也被称为静态链接库，那么什么是静态链接呢？一般情况下的链接就是“静态链接”。
								预编译、编译、汇编               
			***.c   --------------------> ***.o--\    链接（静态链接）
			...                            ...    > ――――――――――――――――――――> 可执行程序（a.exe/a.out）
			***.c   --------------------> ***.o -/
		
	
	静态链接的特点是，所有的.o的代码会组合到一起，最终得到“可执行程序”会包含静态链接的.o中的所有的代码。
	
	
4.4 静态库的缺点
	由于不管有多少个程序链接了静态库，链接时都会包含一份独立的代码到程序中，当这些程序同时运行在同一台
计算机上时，这些重复的代码会比较浪费存储空间。
	图2：

	
	
	
	为了应对静态库的缺点，于是就有了动态库。
		

4.5 制作、使用静态库的详细过程
	后面再详细介绍。
				
				
				
5. 动态库的基本介绍		
		因为静态存在缺点，所以才就有了动态库，动态库就是为了解决静态库的缺点而出现的。
	
	
5.1 如何得到动态库？
	编译源码得到.o，然后再将所有的.o打包为“动态库文件”。
	图：
	
	
	
	
5.2 使用动态库
5.2.1 链接动态库
	动态库也叫“动态链接库”，链接动态库过程为动态链接，动态链接的特点是，链接时并不会直接将库中.o文件中的
代码直接链接到我们的程序中，只会对调用的“动态库的函数名”进行符号解析，告诉编译器编译时先不要报错，所调用
的函数定义在了动态库中，链接动态库后，在“可执行程序”中并不会直接包含对应的代码，只会包含对应的函数接口。
	动态链接提供了一种方法，使程序可以调用不属于其“可执行程序”的函数。
	
	如果被调用函数所在的.o是被静态链接到了程序中的话，调用的这个函数的代码只能在自己的程序中。
	
	
5.2.2 动态库的特点
	运行链接了动态库的程序时，首先检测内存中有没有动态库代码，如果没有的话程序中的“动态库加载器”就会将
所需整个动态库代码从硬盘加载到内存中，程序通过函数接口（函数名（函数指针））调用动态库的函数时，就会
跳转到动态库中去调用动态库的函数代码。
	
	
	不管多少个程序链接了动态库，都只会留下动态库函数的接口，调用动态库函数时共享的同一个动态库的代码，
正是共享的这一特点，可以不用像静态库那样，每个程序都包含一份独立的代码，导致存储空间的浪费。
	图3：
	
	
	
	正是由于动态库的共享特点，因此动态库也被称为共享库。
	
	
5.3 如何制作和使用动态库？
	后面再详细介绍。 
		
	
6. 对比动态库与静态库 
6.1 库知识总结
（1）静态库和动态库都是各种.o打包后的集合体，这个集合体就是“库文件”
（2）链接静态库时，自动在库中找到xxx.o，然后将代码和自己程序的代码组合到一起。
（3）链接动态库时，不会将代码链接到自己的程序中，只会留下函数接口（函数指针）。
（4）动态库是因为静态库的缺陷而产生的，但是动态库并不能完全的替代静态库，后面会介绍原因。
		在某些情况下，我们只能使用静态库，不能使用动态库，因此动态库不可能完全替换掉静态库。
		
6.2 静态库、动态库 与 OS
（1）静态库
		静态库使用原理很简单，链接静态库与链接普通.o文件没有任何区别，所以不管是在裸机上，还是在有OS的计算
	机上，都能运行和使用静态库。
		
		注：裸机就是没有OS的情况。
		
		
（2）动态库
		由于动态库是被共享的，所以必须要有人来提供这套“共享机制”，这个机制的提供者就是OS，所以有OS的支持
	才能使用动态库，而且也不是所有的OS都能提供这套“共享机制”，只有支持“虚拟内存”机制的OS，才能提供
	“共享机制”。
		至于为什么“虚拟内存”能够提供这种“共享机制”，我们在“操作系统”的课程中有介绍，大家可以看这部分内容，
	在这里大家只需要记住，动态库只能基于OS运行，大多数OS比如windows、Linux、Unix、安卓等，都是支持动态库的，
	但是单片机上运行的小型实时OS，可能无法提供“共享机制”，因此无法使用“共享库（动态库）”。
		
		在OS上虽然也能使用静态库，但是由于静态库的缺点很明显，所以但凡OS只要支持动态库的话，在OS上基本只会
	使用动态库，只有在无法动态库的时候才会使用静态库。	
		
		所以在没有OS或者OS不支持共享机制时是不能使用动态库的，只能静态库，因此动态库不可能完全替换掉静态库。
		
		
6.3 所有高级语言都有自己的库吗？
	所有高级语言都有自己各种库，这些事先写好的库可以提高开发效率，因此某个语言受不受欢迎，与它的库丰
不丰富有很大关系，因为库越丰富这门语言使用起来就越方便，开发效率越高。
	在前面就介绍过，面向过程语言的库为函数库，而面向对象语言库的则为类库。
	
6.4 库的好处
（1）可以非常方便复用自己的或前人的劳动成果，以有效提高开发效率
（2）库还可以用来实现软件的功能升级
		比如给原来的程序提供新的功能库，通过这个新的库就可以升级和扩展程序的功能。

6.5 什么时候需要做一个库?
	判断条件很简单，就是当需要复用代码，而且不想以源码和.o形式来复用时，我们就可以选择做成库了。

6.6 各种库举例		
	・ 数学库：各种数学函数，比如开方、平方、sin、cos、log等等数学运算
	・ GL库：Graphic Library，图形图像算法库
	・ 音视频库：实现音视频的编解码、滤波去噪、音视频格式转换
	・ 线程程库：实现多线程
	・ 等等
	
7. 实现库的难点
	实现库的难点并不在于如何制作和使用库，不管你的库是大还是小，是复杂还是简单，制作和使用的规则都是一样的，
没有任何差异，事实上最难的是如何实现库的标准化（规范化）。
	
	所谓标准化就是，让库代码更加的健壮合理，让库函数的功能和函数接口标准化，让库被大多数的编程者所接受，
这个是比较难的。

7.1 个人库
	完全为了方便自己使用而存在的东西，库函数的规范带有很强的个人特点。

7.2 公司内部的库
	为了方便公司产品开发而制作的库，相比个人的库会更加规范。

7.3 c标准库
	所有使用c语言的人基本上都会使用c标准库，printf、scanf、getchar、strlen等函数，都是c标准库提供的。
	
	C标准库的标准是由权威的国际性组织制定的，比如ANSI（美国国家标准学会）、ISO（国际标准化组织）、
IEEE（电气和电子工程师协会）等组织。
	
	这些组织会给出c标准库函数的规范化规定（比如函数功能、函数名、函数参数、返回值等）。
	不过这些组织只会给出规范化规定，c标准库的实现则是由专门的开发团队来实现的，比如针对windows环境的c
标准库，可能是由windows的开发团队来实现的，针对Linux的c标准库，应该是Linux维护团队GNU组织来开发的。
	
	虽然不同环境的c标准库可能是由不同的团队来实现的，但是由于遵守相同的标准和规范，所以我们可以在不同
的平台调用完全相同的c标准库函数（比如printf、scanf、sin、malloc、strcpy等），有关c标准库，我们后面会
详细的介绍c标准库的基本组成。
	
	
7.3 与平台相关c库函数
	c标准库的标准是由“国际性组织”所制定权威标准，一般情况下，不管什么平台都会完整的支持这个标准。
	不过不同平台除了支持通用的c标准库函数以外，可能还会提供完全属于自己平台的c库函数，像这些C库函数
其它平台是不会支持的，只能在自己的平台使用。




出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------
	
8. 制作、使用静态库和动态库
8.1 制作和使用的方法
	方法有两种，
	第一种：是通过IDE图形界面来实现
	第二种：在命令行通过命令来实现
	
	不管哪一种方式都是一样的，都是使用“编译器集合”所提供的命令（程序）来操作的。
	只不过在命令行方式下，我们是直接使用这些命令来操作，而IDE方式则会提供图形界面给我们操作，至于IDE背后是
如何调用命令去实现的，我们无需关心。不过IDE图形界面方式显然会比命令行方式更加的人性化。

	我们会以Windows和Linux这两个平台来对比介绍库的制作和使用，在这两个平台下，我们都可以使用“命令行方式”
和“IDE方式”来实现，如果在这两个平台下，命令行方式和IDE方式都介绍的话，会把搞得太过麻烦，所以我们是这么
安排：
	・ Liunx平台：我们通过命令行方式来实现，Linux下的IDE方式省略
	・ Windows平台：我们通过IDE（Codeblocks）方式来实现，windows下的命令行方式省略
	
	库的制作和使用原理都是类似的，但是由于平台（OS）、编译器、语言的不同，所以在库的制作和使用细节上会
有所差异，很多同学觉得“库的制作和使用”有点混乱，就是因为这样的原因导致的。
	
	我们目前制作c库时，所用的编译器为gcc，OS平台为linux和windows，至于与其它编译器、其它平台相关的c库的
制作，请自行解决。
	
	
8.2 通过Linux命令行来制作c库 
8.2.1 制作、使用静态库
（1）编写需要制作为静态库的代码
		代码实现add/sub/mul/div/power等算数运算函数，然后做成静态库，在我们的程序中链接了这个静态库之后，
	我们就可以调用这些函数来进行算数运算了。
		
		代码文件：
		・ caculate.h：头文件，存放库函数的声明
		・ add_sub.c：加法、减法
		・ mul_div.c：乘法、除法、平方
		
		1）caculate.h
				#ifndef H_CACULATE_H
				#define H_CACULATE_H

				extern double add(double arg1, double arg2);
				extern double sub(double arg1, double arg2);
				extern double mul(double arg1, double arg2);
				extern double div(double arg1, double arg2);
				extern double power(double arg);

				#endif
				
				在程序中使用这些函数时，我们需要对这些函数进行声明，为了方便我们进行声明的操作，我们需要把这些
			函数声明放到.h中，到时候只要包含这个.h即可。
				我们的例子比较简单，目的只是为了向大家演示如何制作和使用静态库，实际上在.h不仅仅只会放函数声明，
			还需要各种宏定义、结构体类型定义、inline函数等等。
				库函数的.h与我们自己的.h没有任何区别，只不过.h所对应的.c被做成了静态库而已。
				
		2）add_sub.c
				#include "caculate.h"

				double add(double arg1, double arg2)
				{
						double sum = 0;

						sum = arg1 + arg2;

						return sum;
				}

				double sub(double arg1, double arg2)
				{
						double sum = 0;

						sum = arg1 - arg2;

						return sum;
				}

				
		3）mul_div.c
				#include "caculate.h"

				double power(double arg)
				{
						double sum = 0;

						sum = mul(arg, arg);

						return sum;
				}

				double mul(double arg1, double arg2)
				{
						double sum = 0;

						sum = arg1 * arg2;

						return sum;
				}

				double div(double arg1, double arg2)
				{
						double sum = 0;

						sum = arg1 / arg2;

						return sum;
				}
				
				注意：库里面是不能包含main函数的，main在我们自己的程序当中。
				
				
				
（2）将源码制作为静态库文件            
			1）得到.o文件 
				gcc -c add_sub.c -o add_sub.o 
				gcc -c mul_div.c -o mul_div.o 
				
			2）将.o文件打包为静态库文件
				ar  -crv  ./libcaculate.a  add_sub.o  mul_div.o
				
				（a）ar：打包命令
				（a）-crv：显示打包过程
					c：打包
					
					v：显示详细过程
				（b）./libcaculate.a：静态库的路径名
							./：静态库的存放路径，你可以指定为任何路径，目前为了演示的便利，我们就放在./下
							libcaculate.a：静态库的完整名字，前缀lib和后缀.a为固定格式，中间的caculate才是真正的静
									态库的名字。制作.a静态库时前缀lib为固定格式。
												
												
				（c）add_sub.o  mul_div.o
							要打包为静态库文件的.o（原料）。
					
					如果制作成功，使用ls查看时，你会发现在当前目录下就有一个libcaculate.a文件。
						file命令查看时，会告诉你静态库文件其实是一个归档文件。
				
						
				再说说ar命令：
				ar命令其实“归档命令”，专门用来实现对文件进行归档，所以说制作静态库文件其实就是制作一个归档文件。
				归档文件和压缩文件很相似，只不过归档文件只打包不压缩，但是压缩文件不仅会打包，而且还会进行压缩。

				
				
				
				
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------
			
			静态库文件放在了ubuntu桌面下的static_lib目录下。
				
（3）使用静态库文件
		1）写一个调用库函数的main.c（放在ubuntu的桌面上） 		
				#include <stdio.h>		
				#include "./static_lib/caculate.h"  //包含静态库的头文件
				
				int main(void)
				{
						double a = 10.5;
						double b = 20.6;
						double ret = 0;

						ret = add(a, b); //加
						printf("add: ret = %f\n", ret);

						ret = sub(a, b); //减
						printf("sub: ret = %f\n", ret);

						ret = mul(a, b); //乘
						printf("mul: ret = %f\n", ret);
						ret = div(a, b);
						printf("div: ret = %f\n", ret);

						ret = power(a);  //除
						printf("power: ret = %f\n", ret);

						return 0;
				}
				
				包含静态库的头文件时，如果caculate.h不在当前路径时怎么办，
				・ 可以在""中指定.h所在的路径
				・ gcc时通过-I选项，将.h所在路径加入"头文件系统路径"
						
				有关“头文件”的相关内容，我们在第2章有非常详细的介绍，不清楚的同学，请看这一章。
					
					
		2）编译main.c并链接静态库
			（a）如果不链接静态库会怎样？
						/tmp/ccTCMbDN.o: In function `main':
						main.c:(.text+0x42): undefined reference to `add'
						main.c:(.text+0x82): undefined reference to `sub'
						main.c:(.text+0xc2): undefined reference to `mul'
						main.c:(.text+0x139): undefined reference to `power'
						collect2: error: ld returned 1 exit status
					
					报一堆的链接错误，提示链接时找不到这些函数的定义，这种链接错误是我么经常会碰到的错误。
					当你在调用某个函数时如果把函数名写错了，同样也会提示你找不到函数的定义的错误，因为而错误的
				函数名肯定没有对应任何的函数定义，自然会报错。
					
					在我们这里并没有把名字写错，而是没有链接定义这些函数静态库，所以找不到函数的定义。
					
					
			（b）链接静态库					
						gcc main.c -o main -L./ -lcalculate -I ./
						
						-I：指定caculat.h所在的路径，路径为./static_lib，如果在头文件处已经指定，则不用加这个参数。

						-L：指定静态库所在的路径（路径为./static_lib），链接时会到该路径下去查寻找静态库。
							
							疑问：能不能省略静态库的路径？
							答：可以
									只要将所在路径加入了环境变量，链接时会指定到该路径下寻找静态库，此时我们不用自己指定
								静态库所在的路径。 
									
									当然还有一种办法，那就是你可以将“库文件”放到之前早就被加入了环境变量的路径，这样也是
								可以的。
								
							
							疑问：如何将路径加入环境变量呢？
							答：我们在《Linux系统编、程网络编程》课程的第4章――进程环境中有详细介绍，请大家看这部分课
							程内容。在课程中windows和Linux的环境变量我们都有介绍了。
							
							
					-l：注意小的是L，这个用于指定库的名字
							指定库名字时需要将前缀lib和后缀.a省略。
							-L指定所在路径，-l指定库名字，如此就会在指定的路径下面找到指定名字的静态库库文件，然后链接它。
							
							其实有关-l，我们在第1章介绍gcc -v详细信息就提到过，有关这一点，请大家看第1章的内容。
			


			
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------
		
8.2.2 制作、使用动态库
（1）编写制作为动态库的例子代码
			我们仍然还是前面制作静态库的代码。

			
（2）制作动态库文件	
		1）得到.o文件 
			gcc -c -fPIC add_sub.c -o add_sub.o 
			gcc -c -fPIC mul_div.c -o mul_div.o 
			
			
			-fPIC：生成位置无关码
				位置有关码：
						代码的地址为绝对地址，代码必须被放在绝对地址所指定的内存位置，这个绝对地址在编译链接时由
					编译器指定，如果不将代码放到指定位置，将无法正确运行。
					
						这就好比两个人接头，指定说在“张家巷128号”接头，这个就是位置相关的，要是不到“张家巷128号”这个
					绝对位置去的话，两个人肯定碰不上面的。
						所以对于位置有关的代码来说，必须运行在“编译链接”时指定地址的内存位置，否则无法正常运行。
						
						总之，位置有关的代码依赖于编译链接时指定的地址，必须把代码放到地址所指向的内存空间，才能运行。
						
						
				位置无关码：
					 代码与绝对地址没有关系，放到内存中任何地址的位置都可以正常运行，这就好比两个人接头时约定，
					双方以烟花为号，大家到放烟花的位置去集合，这就跟绝对地址无关，任何地方都可以碰头，就看烟花
					在哪里。
						
						对于位置无关码来说，不管在代码在内存中什么位置，都可以正常运行，不依赖于编译链接时所指定的地址。
						
						有关位置无关码的具体原理，请看后面uboot的课程，里面会详细介绍。
						
						动态库的代码为什么需要是位置无关的？
						动态库被加载到内存什么位置是不确定的，可能会加载到任何位置，所以必须编译为位置无关码。
						总之，位置无关码的意思就是，代码不会受到内存位置的影响。
				
				
		2）将.o文件打包为动态库文件
				制作动态库的命令不再是ar，而是gcc，而且动态库文件不再是普通的归档文件。
				
			gcc -shared add_sub.o  mul_div.o  -o  ./libmycaculate.so
			
			（a）-shared：制作动态库
			（b）./libmycaculate.so：动态库的路径名
					为了和前面介绍的静态库的名字进行区别，我们这里把动态库的名字取名为mycaculate。
			
			（c）add_sub.o 、mul_div.o
						制作动态库的原料。
						
						
						
						
						
						
						
（3）使用动态库文件
		使用动态库有两步：
		
		・ 链接动态库
		
		・ 加载动态库到内存中
				链接静态库时，代码会直接被包含到程序中，但是链接动态库时，代码并不会被直接包含到程序中，只是
			留了一个“函数接口”，所以需要另外将动态库的代码加载到内存中，如果不加载到内存中，则无法调用动态
			库中的函数。
				
				加载动态库的方式有两种，
				第一种：使用“动态库加载器”来加载，这种是最常见的方式
				第二种：在程序中调用“加载函数”来加载
				
				因为这两种加载方式的不同，所以在程序中调用“动态库函数”的方式也会有所不同。

				
		1）使用“动态库加载器”来加载动态库			
		（a）编写调用动态库函数的程序main.c
					使用“动态库加载器”加载时，调用动态库函数的方式与调用静态库函数是一样的。
					
					#include <stdio.h>
					#include "caculate.h"  //包含动态库态库的头文件
					
					int main(void)
					{
							double a = 10.5;
							double b = 20.6;
							double ret = 0;

							ret = add(a, b); //加
							printf("add: ret = %f\n", ret);

							ret = sub(a, b); //减
							printf("sub: ret = %f\n", ret);

							ret = mul(a, b); //乘
							printf("mul: ret = %f\n", ret);
							
							ret = div(a, b);  //除
							printf("div: ret = %f\n", ret);

							ret = power(a);  //求平方
							printf("power: ret = %f\n", ret);

							return 0;
					}
					
					
		（b）链接动态库
				gcc main.c -L./dynamic_lib -lmycaculate -o main -I./dynamic_lib
				
				-L：指定动态库所在的路径
				-l：指定动态库的名字，需要将lib和.so去掉
			  	通过以上两个选项，就能在指定路径下找到指定名字的动态库，然后链接这个动态库。
				-I：指定动态库头文件的路径
					
				zcw@zcw-PC:~/Documents/Linux-/嵌入式/C语言深度解析/5.制作C库与C标准库组成/库/动态库$ ./main 
				./main: error while loading shared libraries: libcalculate.so: cannot open shared object file: No such file or directory
				
				我们运行程序时会提示说找不到动态库，我们通过ldd命令可以查看程序用到了那些动态库，ldd ./main查
			看，也直接提示libmycaculate.so动态库无法被找到。
					zcw@zcw-PC:~/Documents/Linux-/嵌入式/C语言深度解析/5.制作C库与C标准库组成/库/动态库$ ldd ./main
					linux-vdso.so.1 (0x00007ffee46c2000)
					libcalculate.so => not found//我们自己的动态库
					libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fabcbf0b000)//C标准库的动态库
					/lib64/ld-linux-x86-64.so.2 (0x00007fabcc0ed000)//动态库加载器
		
				无法找到的原因？
				因为“动态库加载器”去加载动态库时，找不到动态库，所以没有能加载到内存中。
				
				那么“动态库加载器”怎样才能找到动态库，并将动态库加载到内存中呢？
				这个问题后面再解决。
				
				
				提问：为什么要链接动态库？
					在程序main.c中我们明确的调用了add、sub等动态库函数，编译时必须对这些函数名进行符号解析，
				而符号解析所需要的信息被包含在了“.so动态库”中，所以编译时必须链接动态库，否则就会提示
				“函数没有定义的错误”，说白了就是符号解析失败。
					main.c:(.text+0x42): undefined reference to `add'
					main.c:(.text+0x82): undefined reference to `sub'
					main.c:(.text+0xc2): undefined reference to `mul'
					....
					
					
					不过有意思的是，linux的下的“.so动态库”会直接包含符号解析所需的各种信息，但是windows下的
				.dll动态库则有所不同，这些符号解析的信息不在.dll中，而是在与.dll配套的“动态库引导文件”中，
				链接时只需要链接“动态库引导文件”即可进行符号解析。
					
					总结起来就是：
				・ 在Linux下：直接通过链接“.so动态库”来进行符号解析
				・ 在windows下：通过链接“动态库引导文件”来进行符号解析，而不是直接链接“.dll动态库”。
					有关“动态库引导文件”，后面还会讲到，这里我们先建立点基本的印象。
				
				
					
				提问：编译链接后，main.c中add、sub等会变成什么?
					add、sub等为动态库函数的函数名，函数名就是函数指针，所以编译后会变成函数的第一条指令的地址。
					如果函数定义就在自己的程序中，那么函数指针一定是绝对地址，因为自己程序中的函数代码会被加载
				内存中什么位置，在编译阶段就能确定，既然能够确定，那么编译时就直接将“函数指针”指定为绝对地址。
				
					但是当调用的是动态库函数时，动态库中的函数定义并不在我们自己的程序中，而是在动态库中。
					链接动态库时只会留下接口，不会将代码包含到自己的程序中，所以动态库函数的定义不在自己的程序中。
					
					而且动态库被加载到内存中什么位置是不确定的，所以说动态库中每个函数在内存中的地址也是不确定的，
				那么编译时，应该将add、sub等函数名翻译为什么样的地址呢？
					
					我们接下来解释一下这个问题。
					不过我们的解释不是100%准确的，与实际情况有所差别，但是如果完全按照真实情况来讲的话，会很难理解，
				如果我们采用不太准确的方式来介绍，虽然有点不太准确，但是不会出大错，关键是好理解。
					
					我们这么来理解，编译时add、sub等会被编译为相对地址，这个“相对地址”为函数在动态库中相对于
				“动态库起始位置”的偏移。
					图：动态库函数相对地址
					
					
					
					动态库在没有被加载到内存中之前，动态库在内存中位置是不确定，但是一旦加载到了内存中后，动态库
				在内存中的起始地址就是确定的，系统会记录下动态库在内存中的起始地址，当程序调用add、sub等动态库
				函数时，
					“相对地址” + “动态库起始地址”  ――――> add、sub等动态库函数在内存中的地址
					
					通过这个地址即可跳转到动态库中add、sub函数处，开始执行这些函数的指令，执行完后再返回。
					图：
					
					
					实际情况会比我们这里描述的更难理解，而且涉及到地址映射的问题，我们这里不需要关心到这个层次。
					
				
						
		（c）“动态库加载器”怎样才能找到动态库，并将动态库加载到内存中？
				・ 动态库加载器
					我们在第1章分析gcc -v的详细过程时就讲过，gcc编译链接程序时，会给我们的程序指定“动态库加载器”，
					/lib64/ld-linux-x86-64.so.2 
					
					前面通过ldd也查看到了这个玩意。
					动态库加载器是自动工作的，我们不需要关心如何去启动它。
					
				・ “动态库加载器”如何才能找到动态库呢？
						“动态库加载器”是通过“动态库环境变量”来知晓，因为“动态库环境变量”中会包含各种动态库所在的路径，
					“动态库加载器”会自动到这些路径下去搜索。
					
						比如C标准库的libc.so的路径就在“动态库环境变量”中，所以“动态库加载器”才会找到libc.so，否者
					printf、scanf这些函数就用不了，而且我们在第1章就介绍过，由于c标准库中的大部分函数会被频繁用到，
					所以gcc会默认自动链接libc.so。
																						
																						/home/zxf/Desktop/dynamic_lib
						总之，我们只要将我们的动态库路径/home/zxf/Desktop/dynamic_lib加入到“动态库环境变量”即可。
						此时动态库加载器必然就能搜索到我们的动态库，然后将其加载到内存中。
					
					
					疑问：如何设置Linux的“动态库环境变量”呢？
						设置命令：
						export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/zxf/Desktop/dynamic_lib
						
						设置完后，我们的程序就能正常运行了。
						
						export：修改Linux环境变量的命令
						LD_LIBRARY_PATH：“动态库环境变量”的名字，变量的内容就是各个动态库所在的路径
						$LD_LIBRARY_PATH：$表示取变量的内容，所以$LD_LIBRARY_PATH代表的是“动态库环境变量”的内容
						:/home/zxf/Desktop：在原有内容基础上，再加一个新的动态库路径，:为不同路径之间的间隔
								新加的路径就是我们的动态库所在的路径。
						
						有关环境变量请看《linux系统编程、网络编程》的第4章 进程环境这一章。
						
						./main
				
						疑问：gcc时不是已经通过-L./dynamic_lib指定了动态库的路径了吗？
						答：这只是给“编译链接”用的，与动态库加载无关。
					
					
				 ・ “动态库加载器”是如何加载动态库的？
						运行程序时，“动态库加载器”会首先检测程序中所用到的“动态库代码”，有没有被加载到内存中，
						
						- 有：不用再加载了，因为动态库是共享的，内存中只需要一份即可
						- 没有：到LD_LIBRARY_PATH指定的每一个路径下去寻找，找到“动态库”后就加载到内存中
							      而且加载时，整个动态库代码会被全部加载到内存中。
					


					
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------				
							
		2）在程序中调用“动态库加载函数”来加载
			（a）Linux下的动态库加载函数
					这里特意强调了Linux下，意思就是Windows下的动态库加载函数与Linux是不一样的。
					
					 Linux下的动态库加载函数是c库函数，但是不是c标准库提供的，而是Linux这个平台的c库函数，也就是说
					在windows下不能使用Linux下的dlopen等函数。
					
					・ dlopen：dynamic library
						- 函数原型：
								#include <dlfcn.h>
								void *dlopen(const char *filename, int flags);
											
						- 功能：打开动态库文件，将动态库文件中的代码加载到内存中。
						
						- 参数：
							filename：动态库的路径名，比如./dynamic_lib/libmycaculate.so，此时库的名字一定要写全名，
								lib和.so不能省略。
								
							flags：打开方式
								flags的选项有好多，由于dlopen函数用的并不多，所以这里只介绍我们会用到的RTLD_NOW选项。
								
								RTLD_NOW：简单理解就是，立即打开动态库文件并加载到内存中，当然这个理解并不准确，但是我们
									目前就先这么理解。如果以后大家真用到了这个函数时，在自己去深入了解这个函数。
												
						- 返回值：
							成功：返回一个void *指针，后续利用这个指针就可以去调用“动态库函数”。
							失败：返回NULL。
							
						
					・ dlclose：
							dlopen用于加载动态库，dlclose刚好相反，用于将动态库从内存中卸载掉。
							int dlclose(void *handle);
							
							参数为dlopen的返回值。
							返回值：成功返回0，失败返回非零值
							
							不过当多个程序都在共享使用动态库时，只要还有一个程序还在调用动态库，dlcose时就不会立即卸载，
						只有当最后一个调用动态库的程序dlcolse时，才会真正的从内存中卸载掉动态库。
							
					・ dlsym
						- 函数原型 
							#include <dlfcn.h>
							void *dlsym(void *handle, const char *symbol);
							
						- 功能
								动态库被dlopen加载到了内存中后，每个库函数的内存地址就是确定的，此时只要得到了
							add、sub、mul等函数入口地址（函数指针：绝对地址），自然就能调用这些函数了。
								
								dlsym的作用就是用来返回“每个动态库函数”在内存中函数指针，只不过返回的类型为void *，
							使用时需要强制转为对应的函数指针类型。
								图：

								
						- 参数
							handle：dlopen返回的指针
							symbol：库函数的名字，为一个字符串，dlsym会通过名字去查找动态库函数的函数指针。
							
							
						- 返回值
							成功：返回某动态库函数在内存中的函数指针
							失败：返回NULL。
						
						
						- 使用例子
							double (*funp)();
							
							funp=(double (*)())dlsym(handle,"sub"); 
							
							由于“动态库代码”中保留了符号名称（字符串），所以才能在动态库代码中通过函数名称找到该函数
						的函数指针。
							
				
			（b）main.c
						#include "caculate.h"  //包含静态库的头文件
						#include <stdio.h>
						#include <dlfcn.h>

						int main(void)
						{
								double a = 10.5;
								double b = 20.6;
								double ret = 0;
								
								double (*funp)() = NULL; //函数指针变量，用于存放dlsym返回的库函数的函数指针
								void *handle = NULL;  //存放dlopen所返回的指针
								
								//打开动态库文件，并将代码加载到内存中，为了让代码简洁一些，我们省略出错处理
								handle = dlopen("./dynamic_lib/libmycaculate.so", RTLD_NOW); 
										
										
								//返回add库函数在内存中的绝对地址，并强制转换为double (*funp)()
								funp=(double (*)())dlsym(handle,"add");  
								ret = funp(a, b);  //通过add的函数指针来调用动态库中add函数
								printf("add: ret = %f\n", ret);

								funp=(double (*)())dlsym(handle,"sub");  //同上
								ret = funp(a, b);  //同上
								printf("sub: ret = %f\n", ret);

								funp=(double (*)())dlsym(handle,"mul"); 
								ret = funp(a, b);
								printf("mul: ret = %f\n", ret);

								funp=(double (*)())dlsym(handle, "div");
								ret = funp(a, b);
								printf("div: ret = %f\n", ret);

								funp=(double (*)())dlsym(handle,"power");
								ret = funp(a);
								printf("power: ret = %f\n", ret);

								dlclose(handle); //从内存中卸载掉动态库
								
								return 0;
						}
												

				（c）编译main.c
						gcc main.c -o main -ldl
						
						运行程序时，会调用dlopen函数会将libmycaculate.so动态库打开并加载到内存中，然后dlsym函数会返
					回每个动态库函数在内存中的函数指针，然后通过函数指针即可调用这些库函数。
						
						・ -ldl是什么意思？
							在linux下，dlopen、dlsym、dlclose由相应的c库提供，只不过并不是c标准库。而且这个c库还是
							动态库，名字叫libdl.so，编译时我们需要通过-ldl来链接。
								如果不链接libdl.so的话，就没办法对dlopen、dlsym等进行符号解析。
							
								提供dlopen、dlsym、dlclose函数的c库是Linxu平台的c库，只在linux平台有效。
							
							
							疑问：为什么没有通过-L指定动态库libdl.so的路径？
							答：libdl.so动态库的路径加入了环境变量，可以自动找到。
								不过要注意的是，这个环境变量不是前面说的那个，与动态库加载有关的“动态库环境变量”，
							而是另外的环境变量，有关这个环境变量我们就不再介绍了，《Linux系统编程、网络编程》会讲。
								
								libm.so  libptread.so  -lmycaculate
							我们在使用数学库、线程库时，要求指定-lm和-lpthread，比如：
							gcc **.c **.c -o a.out -lm   //libm.so
							gcc **.c **.c -o a.out -lpthread  //libpthread.so
							
							
						・ 为什么没有链接libmycaculate.so？
							因为程序中没有直接调用add、sub等动态库函数，"add"、"sub"等只是dlsym的参数而已，不涉及到
						对add、sub等函数名的符号解析，所以不需要链接libmycaculate.so。
						
						
						
						
						
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------				
					
8.3 使用IDE方式来制作、使用静态库和动态库
	我们以windows下的IDE来介绍IDE方式，这样不仅介绍了IDE方式，而且还介绍了windows平台的静态库和动态库。
	我们所用的IDE为Codeblocks，而且Codeblocks使用的编译器也是gcc。
	
	当然，我们也可以在windows命令行使用命令来制作，不过与Linux命令行方式是相似的，所以我们这里不再介绍。
	而且IDE方式才是主流，命令行方式并不是主流。
	
	
	
8.3.1 制作、使用静态库

（1）创建制作静态库的c工程
		1）打开Codeblocks
		
		2）File――>New――>Project―――>Static library――>Next――>输入工程文件名（比如caculate） 和 选择工程存放路径
			演示：
			Untitled4
		
		3）新建三个文件，分别命名为add_sub.c、mul_div.c、caculate.h
				文件的内容不变，还是之前的那些内容。
			
			
			
		4）编译制做静态库
				编译静态库c工程，最后就得到了静态库libcaculate.a，它被放在了工程目录下的bin/Debug/
			或者bin/Release/下。
				
				一般来说在windows平台下，静态库的名字应该叫***.lib，但是前面也说过，静态库的名字与编译器也
			有关系，比如使用gcc编译器来制作静态库时，不管针对的是什么平台，名字都是.a结尾的，当然还有一个
			lib前缀。
			
			
			
		5）我们可以将静态库libcaculate.a和caculate.h集中放到某个目录下，以方便后续使用
				比如在桌面创建一个static_lib目录，将libcaculate.a和caculate.h放在里面。
				
				
				
				
（2）使用静态库
		1）关闭制作静态库的工程，创建一个使用静态库的c工程
		2）新建一个main.c，然后将之前调用静态库的main.c中的内容，复制到当前工程的main.c中
				
				main.c:
					#include "caculate.h"  //包含静态库的头文件
					#include <stdio.h>

					int main(void)
					{
							double a = 10.5;
							double b = 20.6;
							double ret = 0;

							ret = add(a, b); //加
							printf("add: ret = %f\n", ret);

							ret = sub(a, b); //减
							printf("sub: ret = %f\n", ret);

							ret = mul(a, b); //乘
							printf("mul: ret = %f\n", ret);
							
							ret = div(a, b);
							printf("div: ret = %f\n", ret);

							ret = power(a);  //除
							printf("power: ret = %f\n", ret);

							return 0;
					}
		
		3）设置静态库的链接
			（a）指定caculate.h的路径
					Settings――>Compiler――>Global compiler settings――>Serch directories――>add――>caculate.h所在路径
					演示： 
						
					当然，我们也可以直接将caculate.h复制到main.c所在的目录，此时直接#include "caculate.h"即可。
					
			
			（b）指定要链接的静态库
					Settings――>Compiler――>Global compiler settings――>Linker settings――>add――>选择你要链接的静态库
					
					
		4）编译链接、并运行程序
				编辑链接时就会链接我们指定的静态库，然后程序即可正常运行。
				演示：
				
				
							
							
						
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------				
							
8.3.2 通过IDE方式来制作、使用动态库
（1）创建制作动态库的c工程
		1）打开Codeblocks
		2）File――>New――>Project―――>Dynamic Link library――>Next――>输入工程文件名比如mycaculate 和 选择工程存放路径
		
			演示：
		
		3）新建三个文件，分别命名为add_sub.c、mul_div.c、caculate.h
			文件的内容不变。
			
			
		4）编译得到动态库
				编译后就得了动态库，也被放在了工程目录下的bin/Debug/或者bin/Release/下。
					dynamic.dll  
					libdynamic.a   
				
				在Linux下制作动态库时，所得到只有一个***.so文件，但是制作windows动态库时，所得到文件会有两个：
				***.dll：真正的动态库
				***.a：windows下动态库的“动态库引导文件”
				
					这个两个文件合起来等价于***.so，***.a这个“动态库引导文件”也是一个静态库，只不过这个静态库
				里面放的只是动态库符号解析所用基本信息，而不是库函数。
				
			（a）链接Linux下的动态库时：链接的是***.so
			（b）链接windows下的动态库时：链接的是“动态库引导文件”，而不是.dll。
						
		5）将dynamic.dll、libdynamic.a和caculate.h集中放到某个目录下，以后续方便使用
				比如在桌面创建一个dynamic_lib目录，然后放在里面。
		
					
（2）使用动态库
			根据加载动态库方式的不同，分为两种情况：
			
			・ 通过“动态库加载器”加载
			・ 在程序中调用“动态库加载函数”来加载
			
		
		1）方式1：通过“动态库加载器”加载
			（a）创建一个使用动态库的工程
					File――>New――>Project―――>Console application ――>...
			
			（b）将之前调用动态库的main.c中的内容，复制到新工程的main.c中
					main.c:
						#include "caculate.h"  //包含静态库的头文件
						#include <stdio.h>

						int main(void)
						{
								double a = 10.5;
								double b = 20.6;
								double ret = 0;

								ret = add(a, b); //加
								printf("add: ret = %f\n", ret);

								ret = sub(a, b); //减
								printf("sub: ret = %f\n", ret);

								ret = mul(a, b); //乘
								printf("mul: ret = %f\n", ret);
								ret = div(a, b);
								printf("div: ret = %f\n", ret);

								ret = power(a);  //除
								printf("power: ret = %f\n", ret);

								return 0;
						}
			
		（b）设置对动态库的链接
				・ 指定caculate.h的路径，include时才能找到
					Settings――>Compiler――>Global compiler settings――>Serch directories――>add――>caculate.h所在路径
					演示： 
					
						同样的，我们也可以直接将caculate.h复制到工程目录下，include "caculate.h"时，直接在当前目录下就可
					以找到狗文件。
			
				・ 指定要链接的“动态库引导文件”
					Settings――>Compiler――>Global compiler settings――>Linker settings――>add――>“动态库引导文件”所在的路径
	
					
				・ 将***.dll复制到***.exe可执行程序所在目录
						运行程序时，动态库加载器才能找到这个动态库，并加载到内存中。
						
						
		（c）编译链接、并运行
				编辑链接时，会链接“动态库引导文件”，对程序中的add、sub等进行符号解析。 
				要不然会提示找不到add、sub等函数的函数定义。
				
				编译之后就得到了***.exe可执行程序，运行程序时，“动态库加载器”会将***.exe所在目录下的
			mycaculate.dll动态库加载到了内存中，当然，如果之前已经加载了就不再加载。
				
				疑问：为什么linux的动态库和windows动态库会存在区别，.so没有动态库引导文件，而.dll确有动态库
				引导文件？
					
				答：这个区别是由linux和windows目标文件的格式不同导致的，Linux目标文件格式ELF格式，windows
				下的目标文件格式为PE格式，因为这两种格式的不同，而导致了动态库的区别。
					
				

				
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------				
			
		2）方式2：在程序中调用“动态库加载函数”来加载
					linux平台所提供动态库加载函数为dlopen、dlsym、dlclose，同样的，windows平台这边也有对应的
				“动态库加载函数”，分别是LoadLibrary、GetProcAddress、FreeLibrary。
					
						LoadLibrary：类比于dlopen
						GetProcAddress：类比于dlsym
						FreeLibrary：类比于dlclose
						
						使用这几个函数时需要包含windows.h，类比于Linux这边的dlfcn.h。
					
				LoadLibrary、GetProcAddress、FreeLibrary与dlopen、dlsym、dlclose还是有些不同之处：
					・ dlopen、dlsym、dlclose
						Linux平台的C库函数，由libdl.so动态库提供，需要通过-ldl链接对应的动态库。
						
						这几个函数只在Linux平台有效。
					
					・ LoadLibrary、GetProcAddress、FreeLibrary
						这几个函数是Windows的OS API，不需要指定什么-l***来链接。
						
						那么这几个函数也只能在windows下使用。

			（a）创建一个调用LoadLibrary等函数来加载动态库的工程
					File――>New――>Project―――>Console application ――>...
					
					
			（b）在main.c中编写使用LoadLibrary等来加载并使用动态库的代码
					main.c：
						#include <windows.h>
						#include "caculate.h"
						#include <stdio.h>

						int main(void)
						{	
								double ret = 0;
								HINSTANCE handle;  //类比于Linux这边void *handle
								double (*funp)() = NULL;  //函数指针变量
                             
								//类比于dlopen
								handle = LoadLibrary("C:\\Users\\Administrator\\Desktop\\dynamic_lib\\mycaculate.dll"); //windows编译器所用的动态库为.dll结尾
								
								funp = (double (*)())GetProcAddress(handle, "add");  //类比于dlsym
								ret = funp(2.3, 3.6);
								printf("%f\n", ret);		

								funp = (double (*)())GetProcAddress(handle, "sub");
								ret = funp(2.3, 3.6);
								printf("%f\n", ret);		

								funp = (double (*)())GetProcAddress(handle, "mul");
								ret = funp(2.3, 3.6);
								printf("%f\n", ret);	

								funp = (double (*)())GetProcAddress(handle, "div");
								ret = funp(2.3, 3.6);
								printf("%f\n", ret);		

								funp = (double (*)())GetProcAddress(handle, "power");
								ret = funp(2.3);
								printf("%f\n", ret);	


								FreeLibrary(handle); //类比于dlclose(handle)

								return 0;
						}
						
						
						
			（c）指定caculate.h的路径
						与以前是一样的
					
			（d）编译运行
					
					程序运行起来后：
					・ LoadLibrary先将指定路径下的动态库打开，并加载到内存中
						当然，如果内存中已经有一份了，LoadLibrary则不会重复加载的。
						
					・ 通过GetProcAddress函数，即可获得某个动态库函数在内存中的函数指针
					
					・ 得到动态库函数的函数指针后，就可以调用这个动态库函数了
						
						

出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------				
												
8.3.3 使用VC++(IDE)来制作windows平台的静态库和动态库
	我们这里只是大概的介绍一下，具体的实现请大家查阅资料完成，不过目前大家没有必要去深究，以后碰到时在
深究也不晚。
	
	VC++是微软推出的IDE，所使用的编译器自然为Windows编译器，开发的程序基本都是针对windows平台的。
	
	
（1）制作静态库
		使用VC++所制作的静态库为***.lib，显然windows编译器所制作的静态库的名字，尾缀为.lib。

（2）制作动态库
		1）真正动态库：***.dll
		2）动态库引导文件：***.lib，不再是gcc下的.a 

	虽然制作库的原理都差不多的，但是VC++与codeblocks毕竟是完全不同的两个IDE，而且各自使用的编译器也不
相同，因此制作库的细节会有差异，那么像这些有差异东西，我们就不可能一一讲到，这些东西只能由大家在工作
中碰到后自行解决，我的建议是碰到后在解决，没有碰到时就不要去关心了，毕竟我们的时间是很宝贵的，划清
工作和学习的重点是很重要的。

	不过有一点需要说明一下，Codeblocks制作的静态库为***.a，如果想要拿到vc++上使用的的话，需要用工具软件转
为***.lib，同样的***.a动态库引导文件也需要被转为***.lib动态库引导文件。

					
8.3.4 函数手册
	一个正规的库制作完毕后，为了方便编程者使用，我们还应该配上函数手册，使用者通过函数手册，就知道应该
如何调用这些库函数。
		
8.4.5 库的头文件
	对于很重要的库来说，OS或者编译器会自动帮我们提供库所需的.h，include时会自动找到这些.h文件，
	对于一般的库（私人库、公司库）来说，OS和编译器是不可能帮我们提供这些头文件的，我们需要自己添加，至于
如何添加，在前面的课程中已经介绍过了。


8.4.6 再说说静态库和动态库
（1）静态库
			链接静态库后，程序中就会包含所需的代码，编译链接之后，静态Untitled4库对于我的程序来说就没有意义了。
			
			
（2）动态库
			链接动态库时只是留了个接口，程序运行时需要单独的加载动态库
			
		1）对于重要的动态库来说，比如C标准库的动态库，各个平台都会支持，在我们的程序包中不需要包含动态库。
		
		2）对于自己库、公司库来说，平台是不可能提供的，所以我们做好动态库后，需要把动态库和可执行程序
			打包放到一起，将动态库和可执行程序一起发布，只有这样运行程序时才能找到并加载动态库。
		
		
		
9. c库函数与OS API的关系
	如果c库基于OS运行的话，C库函数与OS API的关系如下：
	我们以windows和Linux为例：
	
	C标准库  W平台C库                 C标准库 L平台C库
			 \   /                             \   /
			  API		                            API
			windows                            Linux
			
	基于OS运行时，C库函数会调用OS API，也就是说C库函数会对OS API做封装，比如printf函数向下调用时，封装
OS API为write函数，write在调用底层LCD驱动，将数据输出LCD硬件上显示。
			
			
	c库函数是不是一定会调用OS API呢？
	答：当然不是，有两种情况不会：
	
	1）不需要OS API的支持，那么这个C库函数就不需要调用OS API。
			比如strlen、strcpy函数，只是非常简单的字符串操作函数，不需要OS API的支持，大家其实也能写出这两个
		函数，最多就是代码不如别人规范而已。
	
	2）裸机的c库不会调用OS API，因为裸机时是没有OS的，所以裸机C库与OS API是没有任何关系的。

	
	
	
	
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------				
	
10. c标准库
10.1 c标准
	真正的c标准应该包含两部分内容，一部分用于描述c标准语法，另一个部分则描述c标准库，一个平台如果说要完整
的支持c语言的话，不仅仅要实现c编译器（解释c语法），还要实现c标准库，这样才算符合c标准。
	
	各个平台在实现c标准时，大体上可能会存在两种情况：
	・ 超额符合
	・ 缩水符合
	
（1）超额符合
		所谓超额符合就是，不仅实现了c编译器，实现了c标准库，而且人家还额外的多提供了很多自己平台的c库函数。
		比如Linux下glibc，这个是GNU为linux开发的c库，这个c库>c标准库，或者叫c标准库的超集，glibc除了提供了
	基本的c标准库函数外，还提供了Linux平台独有的c库函数，甚至包括了Linux的OS API。
	

（2）缩水符合
			出现这种情况最多的是单片机开发平台，由于单片机本身的计算机资源的有限，运行完整C库会很吃力，所以很
		多单片机平台（IDE）往往只提供了c编译器，只能对基本的c标准语法进行解释，但是并没有提供完整的c标准库。
		
			不过有些单片机平台（比如stm32）可能会提供“微缩”版的c标准库，以适应单片机资源有限的情况。
	
	
	当然，有关c标准语法我们需要再说一说，大多数平台在实现编译器时，除了支持c标准语法外，往往都会加一些
属于自己的特有语法，想这些c语法只能由该平台的编译器识别，其它平台的编译器是无法识别的，如果我们希望我们
c代码能够在不同的平台都能编译通过，建议写代码时，尽量使用c标准语法。
	当然这个说法也不是绝对的，比如进行单片机开发时，我们往往会使用一些很特别的关键字，这些关键字是只能由该
单片机编译器才能识别的语法，不过此时我们还必须要使用这些关键字，要不然代码就没法写了。

			
			
10.2 c标准库组成
	c标准库由很多子库函数组成，这些子库可能是以如下这些方式来构成c标准库的。

（1）每个子库都被独立的做成了静态库或者动态库，然后集合到一起就构成c标准库
（2）所有的子库函数全被打包做成了一个静态库或者动态库，这个库就c标准库
（3）将某些子库函数打包做成静态库或者动态库，然后这些库合在一起就组成了c标准

	第三情况比较常见：
	比如在linux下，将标准io子库、字符串子库等的scanf、printf、malloc、gmtime、strcpy等常用函数，统统被
打包为了libc.so，而不怎么常用的数学库函数，则被单独的打包为了libm.so。
	为了方便我们使用哪些常用函数，gcc编译时会自动链接libc.so，而使用不常用的数学库函数时，gcc必须
手动指定-lm来链接libm.so，有关这一点，我们在前面的课程中已经多次提及。
		
		
10.2.1 子库
（1）标准IO库
		1）作用：提供标准IO函数，实现输入输出操作，IO（in/out）就是输入输出的意思
		2）头文件：stdio.h 
		3）函数举例
				printf、scanf、getchar、fopen、fclose、fprintf、fscanf、sprintf、fwrite、fread、perror等函数，
			都是由这个标准io库这个子库来提供的，有关常用的标准IO函数，我们在第9章会详细介绍。
			
（2）ctype库
		1）作用：提供字符操作函数，专门用于字符进行处理
		2）头文件：ctype.h 
		3）函数举例
			isalnum：判断字符是否为字母或者数字，比如' '（空格），这个字符既不是字母也不是数字
			isalpha：判断字符是否为字母，比如'a'就为字母
			isdigit：判断字符是否为数字，比如'1'就为数字
			iscntrl：判断字符是否为控制字符，比如回车、换行、D删除、退格等字符就控制字符。
			islower：判断是否为小写字母
			toupper：将小写字母转为大写字母
			...
				
			字符操作函数用的比较少，所以大家不是很熟悉，而且字符操作函数也比较简单，不需要记性专门的学习，
		需要使用时，大家百度一下即可。
				
（3）字符串处理函数库
		1）作用：提供字符串处理的函数
		2）头文件：string.h
		3）函数举例 
			strcat：把某个字符串接到另一个字符串的后面
			strchr：在字符串中，找出第一次出现某字符的位置
			strcmp：对比两个字符串是否相等
			strcpy：将字符串复制到一个字符串数组空间中
			strlen：统计字符串中字符的个数
			strstr：在字符串中，找出第一次出现某字符串的位置
			strerror：将错误号转换为字符串，用于提示函数出了什么错
			...
			
			字符串处理函数的使用频率还是比较高的，有关常用字符串处理函数，我们会在第6章《数组、字符串》中介绍。
		
（4）数学库
		1）作用：提供数学函数
		2）头文件：math.h
		3）函数举例
			abs：求整数的绝对值
			fabs：求浮点数的绝对值
			cos：计算余弦值
			sin：计算正选值
			sqrt：开方
			log：求对数
			log10：求log10x
			pow：计算某个数的n次幂
			...
			
			在实际的c应用开发中，数学库函数使用的比较少，因此我们不会单独的介绍这些函数，大家用到时自己百
		度或则查c标准库函数手册即可。

（5）基础工具函数库
		1）作用：提供基础的工具函数，比如内存管理、字符串转换、随机数、进程环境等
		2）头文件：stdlib.h
		3）函数举例	
		（a）字符串转换函数		
				atof：将字符串转成浮点数，比如将"234.56"转为浮点数234.56
				atoi：将字符串转成整形数，比如将"234"转为整形数234
				atol：将字符串转成长整形数
				strtod、strtol、strtoul：这几个函数稍微有点麻烦，这里就先不介绍了。
				
				以上字符串转换函数，会在第6章《数组、字符串》中，和字符串处理函数一块介绍。
	
		（b）随机数函数
				rand：产生随机数
				srand：设置产生随机数的种子
				
					这两个函数很简单，大家请自行百度用法。
				
		（c）内存管理函数
				malloc：从堆内存中分配变量空间
				calloc：calloc与malloc最大的区别是，calloc会清零开辟的变量空间
				realloc：重新开辟空间，常用于扩充变量空间
				aligned_alloc：分配对齐的变量空间
				free：释放开辟堆变量空间
				
				我们最常用的是malloc和free函数，至于其它的calloc等函数，用不的并不多，不过我们在
			《Linux系统编程、网络编程》的第4章会大致的介绍。
				
				
		（d）进程环境相关的函数
				abort：进程给自己发送一个信号，将自己异常终止
				exit：在程序的任何函数中调用exit时，程序会正常终止
						在main函数中执行return，也能正常终止，但是在子函数中return，只是返回调用的上一级函数，
					而exit则不然，不管在什么地方调用exit，进程（程序）都将会正常终止。
						在main中return与exit是有关系的，有关这一点，就请大家看《Linux系统编程、网络编程》的内容。
				
				atexit：注册进程退出处理函数，进程（程序）在终止时，会调用退出处理函数进行扫尾处理。
				system：开辟一个子进程，然后执行另一个新程序
				getenv：获取某个环境变量
				setenv：设置环境变量
				...
				
				以上这些函数都是与进程环境相关的c标准库函数，我们将会在《Linux系统编程、网络编程》
			的第4章-进程环境 中详细的介绍。
		
				
（6）其它子库――时间函数、信号处理、线程函数
		1）时间函数
				1）作用：提供用于获取系统（OS）时间的函数
				2）头文件：time.h
				3）函数举例
						gmtime：将一个总秒数的时间，转成年月日分秒，放到一个结构体中，供我们使用
							“操作系统”基本都是以秒来累计时间的，这总秒数是从某时间点开始到现在的累计，这个总秒数被
						换算为年月日分秒后，加上那一点的年月日分秒，即可得到公元纪年的时间。
							
						asctime：将结构体中的年月日分秒，转为一个字符串形式的时间
						ctime：直接将累计的总秒数，直接转为字符串形式的时间，比如将总秒数5443434234转
									为"June 1(st), 2018"
						mktime、localtime：...
						...
						
						以上与时间有关的函数，我们在《Linux系统编程、网络编程》的第3章-Linux系统信息中会详细介绍。
		
		
		2）信号处理函数
			1）作用：用于处理信号
			2）头文件：signal.h
			3）函数举例
				signal：捕获信号，并处理信号
				raise：给自身发送信号
				
				c标准库只提供了以上两个与信号有关的函数，有关信号处理函数、以及信号，我们会在
			《Linux系统编程、网络编程》的第6章―信号中详细介绍，那个时候我们会介绍很多与信号相关的函数，
			只不过介绍的函数都是Linux 的OS API，其中有两个OS API也叫signal和raise，用法都是一致的。
					
				所以当你学会了《Linux系统编程、网络编程》的第6章，你自然也就会使用c标准库所提供的signal和raise
			这两个函数了。
		
		3）线程函数
			1）作用：实现多线程
			2）头文件：thread.h(C11)
			3）函数举例
				thrd_create：创建线程
				thrd_detach：通知操作系统，当线程结束时由操作系统负责释放线程所占用的计算机资源
				thrd_exit：此函数用于结束当前线程
				...
				
				c标准库从2011（c11标准的推出时间）后才开始提供c线程库，老版本的编译器可能都不支持c标准库的c线
			程库，但是这些编译器可能会提供其它的c线程库，比如gcc编译器提供的是posix线程库，头文件为pthread.h。
				posix线程库的线程函数为：
					pthread_create：功能同thrd_create
					pthread_detach：功能同thrd_detach
					pthread_exit：功能同thrd_exit
					...
				首字母p就是posix的意思，posix的线程函数与thrd_create等c标准库的线程函数几乎差不多。
				我们虽然没有讲c标准库所提供的c线程库，但是我们在《Linux系统编程、网络编程》的第8章c线程中，
			详细的介绍posix c线程函数，所以大家只要把posix c线程函数搞定了，c标准库的c线程函数非常简单。
				
				
	
10.2.3 c标准库头文件
	c标准库提供了很多的头文件，从c89到c11标准，一直都有不断的添加新的头文件，其中很多的头文件是大家
所不熟悉的，主要是因为这些头文件在c应用开发中用的很少，或者几乎用不到，我们既然时介绍c标准库的组成，
那么我们就有必要了解下，c标准库到底提供了哪些.h文件。
	
	几乎所有c标准库的头文件，在编译器的安装目中都能找到，如果你知道这些头文件中放的是写啥内容，大家可以
自己去打开看看，当然死扣这些头文件，没有意义。
	比如在Codeblocks的MingW目录下的include目录下，就能找到c标准库中几乎所有的头文件，当然由于编译器的版
本问题，有些c11标准新出的头文件，在里面可能是找不到的。
	
	大体上，我们可以将c标准库的头文件划分为两类，一类是功能性头文件、另一类是辅助性头文件。
	
（1）功能性头文件
		stdio.h、ctype.h、sting.h、math.h、stdlib.h、time.h、signal.h。
	
		这些头文件，每一个对应着我们前面所介绍的子库，是我们调用库函数时必须要包含的头文件，属于会被经常
	用到的c标准库头文件。
		
		这些头文件的内容：库函数会用的宏定义、结构体类型定义、内联函数定义、typdef类型等外、以及库函数声明。

（2）辅助性头文件
		1）这些头文件的特点
		（a）在编程中用的并不频繁，而且其中有少数的头文件，只有C标准库自己会用到，在我们的c应用程序中
				一般用不到的。
				
		（b）这些头文件中放的主要是各类宏定义、结构体类型定义，很少放函数声明，因为库函数的声明都放在
				stdio.h、ctype.h、sting.h等功能性头文件中。
		
		2）举例
		（a）比较常用的辅助性头文件
				assert.h、errno.h、stdarg.h、stdbool.h。
				
				assert.h：程序调试所用的“断言”宏，就定义在了这个.h中，有关断言，我们第8章再介绍
				errno.h：函数报错时所用到的各种错误号，就定义坐在了这个.h中，有关函数报错，我们在第8章会介绍
				stdarg.h：可变参数要用的头文件，我们会在第8章介绍。
				stdbool.h(C99)：布尔类型，也就是如果你想使用true、flase来表示真假时，就需要使用这个头文件
						c99表示，从c99标准开始才支持的。
					
					bool flag = true;
					if(flag)
					{
						...
					}
					
					有关bool型，实际用的并不多，因为一般非0为真，0为假就已经很好用了，所以很少有人会经常使用bool型，而老的
					编译器也不支持bool型，因为这个是c99才开始支持的玩意，如果你想来解更多bool类型的话，请大家自行百度，你会
					发现bool这个东西很简单。
				
				
		（b）其它辅助性头文件
				这些头文件我们几乎用不到，不过我们这里还是大概的了解一下，做到心中基本有数即可。	
				complex.h(C99)：与复数运算有关
				fenv.h(C99)：浮点数环境
				float.h：浮点数类型的极限
				inttypes.h(C99)：整数类型的格式转换
				iso646.h(C95)：符号的替代写法
				limits.h：基本类型的大小
				locale.h：本地化工具		
				stdatomic.h(C11)：原子类型
				stdint.h(C99)：定宽整数类型
				stdnoreturn.h：(C11)	noreturn 便利宏
				tgmath.h(C99)：泛型数学（包装 math.h 和 complex.h 的宏）
				uchar.h(C11)：UTF-16 和 UTF-32 字符工具
				wchar.h(C95)：扩展多字节和宽字符工具
				wctype.h(C95)：用来确定包含于宽字符数据中的类型的函数
				stdalign.h(C11)：定义了alignas和alignof，这两个宏与对齐有关，目前了解即可		
			
			
			
				setjmp.h：非局部跳转（长跳转）
						与goto类似，不过goto只能用于函数内部跳转，共同属于局部条转。
						非局部跳转则是用于实现函数之间的跳转长跳转，长跳转往往会带来一些负面效应，就连goto我们都
					建议尽量不要使用，所以长跳转更是不会用到，这里仅仅了解下即可。	
				stddef.h：定义了某些特殊的宏以及类型，比如后面第7章要讲的offsetof宏，就定义在了这个.h中




















