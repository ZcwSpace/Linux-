
=====================================-===================================================================================
============================物联网、嵌入式技术课程 之 《C深度解析》======================================================
=========================================================================================================================

					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	

第2章：预编译 之 宏定义、条件编译、头文件包含、特殊预处理关键字等


1. 本章的意义
		对于好多学C的同学来说，虽然编写自己的C程序时都不是问题，但是一看OS（ucos/Linux/android）、库、框架等C源码
	时就蒙圈，而c又是一门偏底层开发的语言，实际上不管是Linux、还是android等，真正挣钱的开发都是偏底层开发，而底层
	开发又有一个很有特殊的现象，那就是开发时几乎都要涉及相关源码阅读，否则没法开发。
		
		比如你是做Linux驱动开发的，那你就必须阅读Linux OS的驱动框架的源码，否者你没办法开发，因为你根本就不知道应
	该怎么去对接Linux所留的驱动接口，如果你想对接这些接口，没办法你只能阅读源码。

		
		本章要讲的宏定义、条件编译、特殊预编译关键字等等内容，其实是很多学C的同学很容易忽视内容，要么觉得这些东西
	太简单了，要么觉得这些东西没用，自己在写程序过程中几乎用不到这些玩意，正是有这样的观念作祟，所以很多同学
	本章的内容根基不足，等到一看复杂的C源码时才发现，里面大量充斥着你所忽略的内容，而你却不知所云。
		
		所以说本章的内容，往往成为大家阅读复杂C源码的关键障碍，所以希望大家不要再继续忽视本章的内容，学好本章，不仅
	仅能够让你有能力去理解复杂C源码，同时也能够在自己的程序中使用这些内容，提高代码质量。
		
		
		疑问：是不是学好本章，就一定能看懂复杂C源码呢？
		答：当然不是的，要想看懂复杂c源码，本章内容是只是基本条件，比如你想看懂Linux驱动相关源码的话，你还需要动硬件
		相关的知识。
			但是不管怎么说，本章知识是最起码的基础，否则阅读源码中，你会感觉有一大堆看不懂的符号，更不要说看懂代码逻辑了。		
		
			
2. 本章知识点
（1）回顾c预编译

（2）宏定义
	（a）宏定义的作用
	（b）无宏体宏 与 有宏体宏
	（c）带参宏
	（b）宏定义与复杂表达式
				
（3）条件编译
	（a）条件编译的意义
	（b）#if、#else、#elif #endif 
	（c）#ifdef和#ifndef 
	（d）#if 与 defined的结合
	（e）条件编译与配置文件（条件编译的真实应用）
		
（4）一些特殊的预编译关键字 与 实际应用
	（a）defined
	（b）#error
	（b）#line
	（c）# 与 ##
	（d）#pragma 

（5）文件包含
	（a）是不是只能包含头文件
	（b）为什么尽量不要include .c文件
	（c）<>与""区别

		

出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
		

课程内容		
1. 回顾C预编译（预处理）

	1.1 编译的四过程（四阶段）
			
			      预编译          编译           汇编
			***.c ——————> ***.i ———————> ***.s ———————> ***.o ——|
																											    |
                                                          |   链接																												
									         ......                 	       >————————>a.out
										                                      |
																									        | 
		  ***.c ——————> ***.i ———————> ***.s ———————> ***.o ——|  
			                                                    |
			                    编译器提供的其它.o（启动代码）——|
																		                      |
																		库（静态库、动态库）——|
			

	1.2 预编译时做的五件事情
			我们在第一章详细地介绍过这四个阶段，由于本章与第一阶段“预编译”有关，我们这里需要回顾“预编译”阶段。
		
		（1）头文件包含
					在.c文件中，将所有#include <***.h>展开，说白了就是将.h中的宏定义、函数声明、结构体类型定义等等内容
				复制到.c中，以供第二阶段“编译”时使用。
		
		
		（2）宏替换
				预处理后，宏会被宏体所替换，宏名消失。

				
		（3）条件编译
				预编译时条件编译（代码选择开关），会选择哪些代码留下，哪些代码去掉，预编译后“条件编译”就消失了。
				
				
		（4）处理#error、#line、#、##等一些特殊的“预编译关键字”
				
				
		（5）处理注释
					注释只是给程序员看的，cpu运行时并不需要，预编译之后，//、/* */所标记的注释将不复存在。
		
			
	1.3 本章的重点是什么？
				预编译阶段所做的事情我们清楚了，其实就是处理宏定义、条件编译、头文件包含、特殊预处理关键字这些内容，
			本章的重点就是详细的讲解下“宏定义、条件编译、头文件包含、特殊预处理关键字”。	
	
	
	1.4 c预处理代码特点
			所有C的预处理代码，比如#define、#include，#if等都是独占一行，而且结尾没有;。
		#define PI 3.14  
		#include <stdio.h>
		
		#if NUM == 500
		...
		#endif
		
		
		为什么结尾没有;
			因为凡是;结尾的东西，都是由第二阶段“编译”来处理的（a.i->a.s），而所有预编译的代码都是在预编译阶段处理的，
		为了以示区分，所以所有预编译的代码都不需要分号结尾。
			
			
			
2. 宏定义			

	2.1 宏定义的用途

		（1）减少重复劳动
					比如，程序中有很多地方都要用到100这个数，当需要将100修改为200时，就需要到每个引用100的地方将100改为200，
				这就是重复劳动。此时最好就将100定义为宏，
					#define NUM 100,
				
					如果需要将100修改为200时，只要修改NUM即可，在预处理时NUM自动就会被替换为200。
				
		（2）方便阅读
					我们在定义每个宏时，宏名都是有一定含义的，而不是随便定义的，有意义的宏名能够帮助我们阅读和理解代码，
				比如：
					#define PI 3.14
				
				一看这个宏名你就知道这是圆周率，如果在程序中直接写3.14的话，很难理解这个数字的含义。
					
					
		（3）简化复杂表达式
					简化使用调用。
					#define AREA(a,b) (((a)+(b))*((a)-(b)))/a*b
					
					在代码中直接调用AREA带参宏，显然简化了代码，向这类的简化复杂表达式的宏，在复杂C源码中非常多，由于这类宏
				的宏体复杂，往往也成为了很多同学阅读复杂C源码的障碍之一。
				
				
		（4）与条件编译配合使用
				#define ARM
				
				#ifdef ARM 
				...
				
				#endif
				
				
	2.3 宏的种类
			宏有两种，一种是有宏体宏，另一种是无宏体宏。
		
		· 无宏体宏：#define X86
		· 有宏体宏：#define NUM 100，#define AREA(r) (r)*(r)*3.14
		
		
		2.3.1 无宏体宏
			（1）什么是无宏体宏
					只有宏名、没有宏体。
							
			（2）定义形式
					#define 宏名  
					
			（3）举例
					#define X86
					
					预编译完后，由于这个宏没有宏体，所以宏直接替换为空，空就是啥也没有。
					
			（4）这种宏有作用吗
						有作用，后面讲到条件编译时再介绍。
						
			


出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
	
		2.3.2 有宏体宏	
				有宏体宏分为两种，一种是无参宏，另一种是有参宏。
					
					无参宏：没有参数，#define NUM 100
					有参宏：有参数，#define AREA(r) (r)*(r)*3.14
		
		
		（1）无参宏		
				1）定义形式	
					#define 宏名 宏体
					
				3）举例
					 #define		 YES   		1
					 #define     NO     	0
					 #define     PI      	3.1415926
					 #define     OUT     	printf(“Hello,World”);
					 
					预处理后，宏名会被替换为宏体。
		
		
		
		（2）带参宏
				1）定义形式	
					 #define	宏名(参数表)	宏体
					
					
				2）举例
						#define  S(a,b)  a*b*10
						
						int main(void)
						{
							int va;
							
							va = S(3,2); //3对应a，2对应b
							
							printf("va = %d\n", va);
							
							return 0;
						}
						
						预编译处理时，将宏体中的a和b，使用参数中的3和2来替换。
						
						va = S(a, b) ——————> va = 3*2*10
					
					
				3）带参宏需要注意之处
				
					1）宏名和参数列表之间不能有空格
					
							#define  S (a,b)  a*b*10    
					
					
						 由于S和(a, b)之间有空格，宏名变为了S，宏体变为了(a,b) a*b*10，含义发生了变化。
						
					
					2）写带参宏的时，不要吝啬括号
							#define  S(a,b)  a*b*10
						 
							其实这个带参宏是有缺点的，如果参数写成如下形式的话，替换后结果可能就完全背离了你的本意。
									a    b         
							 S(x+1, y+2) ——————————————> x+1*y+2*10
							 
							对于预编译器来说，它再处理宏定义时，它并不知道你的使用意图是什么，它只会忠实的进行替换工作，但是
						替换之后是否能够达到你要的效果，这个就不一定了。
							
				
							怎么解决？
							为了避免这种情况，大家在定义带参宏时不要吝啬括号。
							
							#define  S(a,b)  ((a)*(b)*10)   //为了保险起见，对整个宏体也要加()。
							
							S(x+1, y+2) ——————————————> ((x+1)*(y+2)*10)

							疑问：为什么要对整个宏体加括号？
								#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
								#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
								#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
								
								*ETH_MMC_BASE = 0x67667732;
								
								如果不加括号的话，*ETH_MMC_BASE = 0x67667732;就变为了
								*ETH_BASE + 0x0100 = 0x67667732。
								
								所以，凡事宏体是一个表达式的情况，我们都要求对整个宏体加()，以保证宏展开一定不会出错。
								
									
				4）带参宏 与 函数			
					这两个玩意儿长得很像，但实际上是两个完全不同的东西。
					
					1）例子
							#include <stdio.h>
							
							#define  S(a,b)  a*b*10
							
							void s(int a, int b)
							{
								return a*b*10;
							}
							
							
							int main(void)
							{
								int va1, va2;
								
								va1 = S(3, 2); //引用带参宏
								
								va2 = s(3, 2); //调用函数
								
								printf("va1 = %d, va2 = %d\n", va1, va2);
								
								return 0;
							}
	
							仅仅从调用来看，这两个东西确实长得很像，如果将宏也定义为小写的话，仅看调用的话，很难看出这个到底谁
						是函数谁宏定义。
						
							为了能够让大家快速的区分带参宏和函数，大家在定义宏的时候，宏名一定要大写，否则在阅读代码时，很容易
						与函数搞混，非常不利于代码的阅读和理解。
						
					
					2）二者的区别
							二者是有着本质区别的：
							
						（a）带参宏
								· 处理阶段：预编译
										宏只是一个供我们程序员识别的一个符号，一旦预编译之后带参宏就会消失了，取而代之的是宏体。
									
									演示：
									
									
								· 参数列表
										带参宏的形参是没有类型的，我们使用int 、float等类型只有一个目的，就是使用类型来开辟一个变
									量空间，变量空间的字节数和存储格式是由类型来决定的，所以定义变量时必须要有类型说明。
										
										而带参宏的参数仅仅只起到替换说明的作用，不需要开辟空间来存放实参的值，既然不需要开辟空间，
									那就不需要类型的说明。
									
									
						（b）函数
								· 处理阶段：由编译、汇编、链接阶段处理
									在“预编译阶段”是不会处理函数这个东西的，在预编译前后，函数没有任何变化。
									
									演示：

									- 编译：将c形式的函数编译为汇编形式的函数。
									- 汇编：将汇编形式的函数，转为二进制指令的函数
									- 链接：进行符号统一和重定位
									
									
								· 函数是一个独立体，有调用的过程
										运行函数时涉及调用的过程，
										
									- 调用时：从当前函数跳转到被调用的函数，开辟形参和自动局部变量时，涉及压栈操作。
									- 调用结束：返回到调用函数，释放函数的形参和自动局部变量的空间时，涉及弹栈操作
								
										
								· 函数的参数列表
									函数的形参是需要被开辟空间的，所以必须要要有类型说明。
		
		
		

出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
		
	2.3 宏的一些值得强调的地方
		
		2.3.1 预处理完之后，宏定义和宏引用都会消失
		
		
			#define NUM  100  //宏定义，预处理后消失
						
			int main
			{
				int a;
				
				a = NUM;  //宏引用，预处理后被替换为宏体，宏引用消失
				
				return 0；
			}
					
		
		2.3.2 宏名的字母一般习惯大写，以便与变量名、函数名相区别
				有关宏名大写的习惯并不是没事找事，如果宏名小写的话，会很容易和正常的变量和函数混淆。
				
			（1）小写的无参宏很容易和变量混淆
					#define pi 3.14
					
					int a = 10;
					
					int main(void)
					{
						int c = a + pi;
						
						return 0;
					}
					
					如果pi不大写的话，仅看使用的位置，很难判断出pie是宏还是变量。
					
					
			（2）小写的带参数宏很容易和函数混淆
					#define area(a, b)  ((a)*(b))
					
					int main(void)
					{
						int c = area(10, 20); //仅看调用的位置，很难判断area是一个宏还是一个函数。
						
						return 0;
					}
				
					
			（3）宏名与变量和函数混淆到底有什么不好
			
						我们在实际开发时，不管是因为调试还是代码维护的原因，我们都需要阅读别人的源码，或者别人阅读自己的源码，
					或者自己阅读自己的源码（程序写大了自己都糊涂了），阅读代码时我们不可能每个函数都去查看它的定义，我们需
					要通过名字快速识别然后了解它的作用，但是如果你把宏和变量函数都定义成小写的话，阅读宏时就很容易误解为变
					量和函数，但是实际上它们之间是有本质区别的，这种理解的错误就非常容易给我们代码阅读带来很多的困惑，进而
					影响代码的调试和维护。
							
						正是基于这样的道理，我们这里要求大家尽量将宏写成大写的，而且一定要见名识意。
						
						疑问：难道真的没有小写的宏吗？
						其实也不是，在少数某些特殊情况下，还真有定义为小写的，但是这种情况比较少见。
						
						比如大家在学习标准IO函数时，有三个宏（stdio.h）：
						stdin：标准输入（从键盘输入数据）
						stdout：标准输出
						stderr：标注出错输出
						
						这三个宏其实就是小写的，之所以写成小写，应该是历史遗留问题。
						除了少数的特例之外，对于宏来说，我们要都要大写。
									
				
		2.3.3 宏定义不是C语句，不必在行末加分号
		
			这个在前面就介绍过，不过以下例子的;算什么
			
			#define STUDENT struct student{int a; int b;};
			
			
			例子中的分号只是宏体struct student{int a; int b;};的一个组成部分而已。
			
			
					
		2.3.4 所有预编译的代码都是独占一行的（不能多行）
			#define STUDENT struct student{int a; int b;};
			
			为了独占一行，我把结构体写在了一行中，但是这样子不方便理解，我们往往会把它改成如下形式
			#define STUDENT struct student{\
				int a; \
				int b;\
			};
			
			加了\（连行符）后，其实这几行在同一行中。
	
		
		2.3.5 宏的作用域 与 #undef
				正常情况下的宏作用域为从定义为位置开始，一直到文件的末尾。如果你希望结束宏的作用域的话，可以使用#undef
			这个预编译关键字。
				
				a.c
				#define NUM 100 
				
				int fun();
				
				int main(void)
				{
					int a = NUM;
					
					return 0;
				}
				
				#undef NUM
				
				int fun()
				{
					int a = NUM;//这里将无法使用这个宏
				}
				
				这里虽然是以.c文件来举的例子，但是如果将宏定义在.h中时，它作用域以及#undef的用法也是一样的。
				
				对于#undef这个预编译关键字来说，在我们自己的代码中用的比较少，但是大家在阅读OS、库、框架等复杂C源码时，
			不时的还是会见到这个关键字。			
			
			
		2.3.6 定义宏时可以嵌套引用其它的宏，但是不能嵌套引用自己
		
			（1）嵌套其它宏
					#define   WIDTH   	80
					#define   LENGTH   	(WIDTH)+40
					#define   AREA			WIDTH*(LENGTH)
					
					int main(void)
					{
						int a = AREA;
					
						return 0;
					}
					
					
					请问：如下写法正确吗?
					#define   AREA			WIDTH*(LENGTH)
					#define   WIDTH   	80
					#define   LENGTH   	(WIDTH)+40
					
					int main(void)
					{
						int a = AREA;  WIDTH*(LENGTH) ————>80*(LENGTH) ————>>80*40
					
						return 0;
					}
					
					
					
					这个写法是正确的，只要宏引用的位置在定义位置的作用域范围内就行。
					
					显然AREA的引用都在AREA、WIDTH、LENGTH作用域内，所以AREA的引用在替换时，完全不存在任何问题。
					
					int a = AREA ——> int a = WIDTH*(LENGTH) ——> int a = 80*(80+40)
				
					所以只要宏引用的位置都在“宏定义”的作用域范围内，对于有嵌套关系的几个宏来说，它们的先后关系不存在任何
				影响。
			
			
			（2）为什么不能嵌套自己
					#define  AREA	  AREA*10
					
					int main(void)
					{
						int a = AREA;
					
						return 0;
					}
					
					进行宏替换：
					int a = AREA ————> int a = AREA * 10
					
					从这个例子可以看出，嵌套自己时在预编译器做完替换后，最后还剩一个宏名，这个宏名无法再被替换，最后留给
				第二阶段编译时，将变成一个无法识别的符号，从而报错。
					
					所以宏不能嵌套自己，这个函数不一样，函数嵌套调用自己是递归，宏嵌套引用自己就是犯错。
					
				
		2.3.7 只作字符替换，不做正确性检查
		
			（1）为什么不做正确性检查
						预编译器处理宏时，预编译器只关心替换的事情，至于替换的宏体的写法是否正确，预编译器
					本身并不做检查，因为判断写法是否正确的这件事情是由第二阶段的编译来做的。
				
			（2）例子	
				  a.c
					
					#define NUM 100WEE
							
					int main(void)
					{		
						int a = NUM;
							
						return 0;
					}		
					
						例子中整形数100WEE的写法完全是错的，但是在预编译时根本不会提示任何错误，预编译器会忠实的将NUM换为
					100WEE，
					演示：gcc -E a.c -o a.i  //仅预编译
					
					
					但是后续编译时就会报无法识别100WEE的错误。
					演示：gcc -S a.i -o a.s 
				
				
				
				


出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
	
	2.4 预定义宏
			__DATE__、__FILE__、__LINE__、__TIME__、__func__。
			
			其实预定义宏不止这些，不过这里我们就只介绍这些。
			
			
		2.4.1 什么是预定义宏
				预定义宏，也可以称为编译器内置宏，这个宏并没有定义在哪个.h文件中，所以不能再哪个.h中找到这些玩意。
			进行预编译时，当预编译器看到这些玩意时，会自动处理这些预定义宏。
				
				其实将这些预定义宏称为预编译关键字，可能更好些。
					
				
		2.4.2 作用
			（1）__DATE__：代表预处理的日期
						当预处理器检测到__DATE__后，会将其替换为"月 日 年"的字符串形式的时间，时间格式是西方人习惯的格式。
					
					
			（2）__FILE__：代表当前预编译正在处理的那个源文件的文件名
						当预处理器检测到__FILE__后，会将其替换为"***.c"的文件名。
					
					
			（3）__LINE__：代表__LINE__当前所在行的行号
						当预处理器检测到__LINE__后，会将其替换为__LINE__当前所在行的行号（整形）。
						
			
			（4）__TIME__：代表对源文件进行预编译时的时间
						当预处理器检测到__TIME__后，会将其替换为“hh：mm：ss”格式的时间。
						
						
			（5）__func__：当前__func__所在函数的函数名 
						不过这个在预编译阶段不会被处理，而是留到编译阶段处理。
						
					
			（6）例子
					helloworld.c
						#include <stdio.h>

						int main(void)
						{       
							printf("预编译的日期:%s\n", __DATE__);
							printf("预编译的文件:%s\n", __FILE__);
							printf("当前所在行号:%d\n", __LINE__);
							printf("预编译的时间:%s\n", __TIME__);
							printf("当前所在函数:%s\n", __func__);

							return 0;
						}
						
						查看预编译结果：
						int main(void)
						{
							 printf("预编译的日期:%s\n", "Jul  5 2018");  //替换为了日期
							 printf("预编译的文件:%s\n", "helloworld.c"); //替换为了文件名
							 printf("当前所在行号:%d\n", 7);  						//替换为了__LINE__所在的行号
							 printf("预编译的时间:%s\n", "02:21:08"); 		//替换为了预编译的时间
							 printf("当前所在函数:%s\n", __func__);	//没有替换，到第二阶段编译时再处理，__func__代表的函数名是main

							 return 0;
						}
						
						打印结果：
							预编译的日期:Jul  5 2018
							预编译的文件:helloworld.c
							当前所在行号:7
							预编译的时间:02:28:15
							当前所在函数:main
						
						
						除了__func__外，其它几个都可以定义相应的变量来存放，比如。
						int line = __LINE__;
						char date[] = __DATE__;
					
					
		2.4.3 预定义宏的意义 与 调试宏					
			
			（1）意义
					常常用于调试打印、跟踪代码用。
			
					当一个程序写大了后，在调试程序的功能性错误时，往往需要打印信息来跟踪代码，看看程序是运行到什么位置时
				才出现了功能性错误，以方便我们调试。
					printf("%s %d %s\n", __FILE__, __LINE__, __func__);
		
					当然如果不需要显示文件名和函数名的话，其实直接打印行号就可以了。
					printf("%d\n", __LINE__);
					
					
					
			（2）调试宏
					在每个需要打印的地方都写printf会非常的麻烦，因此我们可以把它写成调试宏。
					
					1）例子：
							#include <stdio.h>
							
							//调试宏，DEBUG的名字可以自己随便起
							#define DEBUG printf("%s %d %s\n", __FILE__, __LINE__, __func__);
							
							void exchange(int *p1, int *p2)
							{      
								DEBUG
								int tmp = 0;
								DEBUG
								
								tmp = *p1;
								DEBUG
								*p1 = *p2;
								DEBUG
								*p2 = tmp;
								DEBUG
							}
																			
							int main(void)
							{       
								int a = 10; 
								int b = 30; 
								
								DEBUG							
								exchange(&a, &b);
								DEBUG
								
								printf("a=%d, b=%d\n", a, b);
							
								DEBUG
							
								return 0;
							}
						
							通过打印信息来跟踪程序，其实有些时候比“单步运行调试”更好用，因为单步运行调试在某些情况其实很麻烦，
						不如打印信息来的好使。
						
						
					2）如果你想打印自定义信息的话，我们还可以将调试宏定义为带参宏
						#define DEBUG(s1, s2) printf(s1, s2);
					
						在程序中使用时，可以指定你要任何打印的调试信息。
						DEBUG("%d\n", va); //你想写什么，可以由你自己决定。
						DEBUG("%s\n", str);
					
					
						疑问：感觉这也不比直接写printf("%d\n", va)更方便呀？
							不直接使用printf，而是写成DEBUG(s1, s2)带参宏的形式，可以方便我们使用“条件编译”来快速打开和关闭
						调试宏，后面将再介绍这个问题。
					

			

			

出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
					
	2.5 宏的一些深入用法的例子
			
			大家可能感觉宏比较简单，所以大家往往容易忽略宏的存在，实际上在很多的复杂C源码中，往往可以经常看到各种宏
		的比较深入的用法，所以我们这里举一些宏的比较高级的、比较深入的用法的例子，举这些例子的目的有三个
		第一个：提高对宏的认识，希望大家能够适应c源码中宏的深入用法
		第二个：向大家如何分析这些比较复杂的宏，当自己遇到类似比较复杂的后，能够自己去分析这些宏
		第三个：希望大家也能够学会在自己的代码中，按照类似的方式去模仿宏的比较深入的用法，提高自己的代码质量
			
			
		2.5.1 例子1：使用宏来代替简短函数
			比如：
				#include <stdio.h>
				
				void exchange(int *p1, int *p2)
				{       
					int tmp = 0;
					
					tmp = *p1;
					*p1 = *p2;
					*p2 = tmp;
				}
																
				int main(void)
				{       
					int a = 10; 
					int b = 30; 
													
					exchange(&a, &b);
																	
					printf("a=%d, b=%d\n", a, b);

					return 0;
				}

			（1）例子中exchange函数就是一个简短函数
					那么什么是简短函数呢，如何判断一个函数是不是简短函数呢？
					
					1） 代码只有1~5行左右
					2） 函数中没有循环
							因为如果有循环的话，也相当于有很多的代码，不过如果你的循环要是非常短的话，比如只循环3~4次，累计的
						代码量也就只有5行左右的话，也算是简短函数，不过一般来说，我们并不把有循环的函数算作是就简短函数。
				
				
			（2）简短函数缺点：调用开销比较大
					1）时间开销：调用时跳转到被调函数处执行，函数执行完毕后，返回到调用处，这些都是需要时间的。
					2）空间开销：调用函数时，往往需要在栈中为形参开辟空间，所以有空间开销
						而且开辟和释放形参的空间，也是需要时间的，也有时间开销。
						
						所以对于简短函数来说，函数调用的开销甚至都有可能大于那1~5行代码的运行开销，所以说如果你在程序中有大量
					的简短函数的话，会非常影响你的程序质量，特别是当这个简单函数会被频繁调用时，累积的开销就更大了，所以
					这个时候就可以使用“带参宏”来代替了。
						
						
			（3）使用带参宏来代替简短函数
					helloworld.c 
						#include <stdio.h>
				
						#define EXCHANGE(p1, p2) \
						{
							int tmp = 0;\
							tmp = *p1;\
							*p1 = *p2;\
							*p2 = tmp;\
						}//代码块
																		
						int main(void)
						{       
							int a = 10; 
							int b = 30; 
															
							EXCHANGE(&a, &b);
																			
							printf("a=%d, b=%d\n", a, b);

							return 0;
						}		
					
					1）查看预编译结果：gcc -E helloworld.c -o helloworld.i
						
							EXCHANGE(&a, &b) ————>  int tmp = 0; tmp = *&a; *&a = *&b; *&b = tmp;;
						宏展开后，代码直接成为了main函数的一部分，不存在函数调用的过程，省去了函数的调用开销。
						
							使用宏来实现时可以不使用指针，不过用了也没错。
						
							总之为了效率着想，大家完全可以使用宏来代替简短函数，特别是当程序非常大时，这是很有意义的。
					
										
							注意我们说的只是简短函数使用宏代替，不要什么函数都使用宏来代替，如果都使用宏来代替的话，会导致程序的
						代码量急剧上升，代码变大了自然就需要更多的内存空间来存储，这也会带来很大的空间开销。
						
							为什么代码量会急剧上升？
								因为所有引用这个宏的地方都会进行宏展开，每个引用宏的地方都会重复包含一份完全相同的代码，程序的
							代码量自然会急剧上升，所以什么事都不能走极端，走了极端就出麻烦。
						
					
					2）使用宏来代替简短函数，其实还存在一点小小的缺点
							那就是预编译时，宏的参数只是做简单的替换，而不做类型检查，也就是不检查实参类型与形参类型对不对。
							
							为什么宏不做类型检查？
								因为宏的形参就没有类型，自然没办法进行类型检查，假如你引用EXCHANGE时，你写成了EXCHANGE(100, 100)，
							此时实参的类型是int，并不是宏体所需要的指针类型，这显然是有问题的，但是预编译时不会进行类型检查，
							只是简单替换。
							
								但是函数的形参有类型说明，所以编译时会检查函数的实参与形参的类型是否匹配，类型检查其实是很有用的，
							因为编译时的类型不匹配的提示信息，非常有利于我们排查编译错误。
	
								宏只做替换，不做类型检查，函数会做类型检查，但是不做替换(函数只能调用)，为了将二者的特点融合下，
							后来就有了“内联函数”，内联函数的特点是
								（a）有函数的特性：内联函数的形参有类型，会进行类型检查
								（b）有宏的特点：内联函数和宏一样，也是一个替换的过程，不存在函数调用
								
								说白了内联函数就是一个宏和函数的特点相综合后的产物，所以对于简短函数来说，最好的方式是使用内联函数
							来实现。
							
								在Linux内核源码中，会经常看见内联函数这个东西，因为Linux内核必须考虑效率问题，所以几乎所有会被
							频繁调用的简短函数，都使用内联函数来实现，不过有关内联函数这个东西，我们讲函数时在详细介绍。

							
								实际上你只要注意不要把参数类型弄错了，使用带参宏来替代简短函数，其实也是很好的，在很多源码中，经常
							会看到这样的用法，因为内联函数也有一个问题，那就是它依赖于编译器的支持，因为内联函数相对来说算是一个
							比较新的C语法特性，有些老旧的编译器不一定支持，但是你使用带参宏肯定是没问题的，因为宏是一个老的C语
							法特性。
	
								不过内联函数的出现也有好些年了，所以现在的编译器应该几乎都支持了。
			
			
			
			
			

出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
	
		2.5.2 例子2：使用宏来减少函数定义，简化函数调用						
				
				recode_lock.h//文件锁
					#ifndef ___RECODE_LOCK__
					#define ___RECODE_LOCK__
					
					#include <unistd.h>
					#include <fcntl.h>
					#include <stdlib.h>

					
					/* 加非阻塞读锁 */
					#define read_lock(fd, l_whence, l_start, l_len) \
						lock_set(fd, F_SETLK, F_RDLCK, l_whence, l_start, l_len)
					
					/* 加阻塞读锁 */
					#define read_lockw(fd, l_whence, l_start, l_len) \
						lock_set(fd, F_SETLKW, F_RDLCK, l_whence, l_start, l_len)
					
					/* 加非阻塞写锁 */
					#define write_lock(fd, l_whence, l_start, l_len) \
						lock_set(fd, F_SETLK, F_WRLCK, l_whence, l_start, l_len)
					
					/* 加阻塞写锁 */
					#define write_lockw(fd, l_whence, l_start, l_len) \
						lock_set(fd, F_SETLKW, F_WRLCK, l_whence, l_start, l_len)
					
					/* 解锁 */
					#define unlock(fd, l_whence, l_start, l_len) \
						lock_set(fd, F_SETLK, F_UNLCK, l_whence, l_start, l_len)

						
					/* 操作锁的函数 */
					static int lock_set(int fd, int l_ifwset, short l_type, short l_whence, \
						off_t l_start, off_t l_len)
					{
						int ret = -1;
						struct flock f_lock;
						
						f_lock.l_type = l_type;
						f_lock.l_whence = l_whence;
						f_lock.l_start = l_start;
						f_lock.l_len = l_len;
						
						ret = fcntl(fd, l_ifwset, &f_lock);//加锁解锁
						
						return(ret);
					}

					#endif

					
				helloworld.c 
					#include <stdio.h>
					#include <stdlib.h>
					#include "recode_lock.h"
					
					int main(void)
					{	
						int ret = 0, fd = -1;
							
						fd = open("./file", O_CREAT|O_RDWR|O_APPEND|O_TRUNC, 0777);
						if(fd < 0)
						{	
							perror("open is fail");
							exit(-1);
						}	
						
						while(1)
						{
							//加阻塞读锁，也就是加锁失败，程序会休眠在这里，就像scanf没有数据，也会休眠一样
							read_lockw(fd, SEEK_SET, 0, 0); 
							
							write(fd, "hello ", 6);
							write(fd, "world\n", 6);
							
							unlock(fd, SEEK_SET, 0, 0); //解锁
						}	
					}		
					
					这个是我后面讲《Linux系统编程、网络编程》的例子，我们来分析下这些宏，理解这些宏的作用是什么？
					
					
			（1）分析这些宏
					
						像这类宏参数很多，密密麻麻，很多同学一看到这种宏就讨厌，但是不用担心，分析这类比较复杂的宏定义时是
					有办法的，办法就是进行宏的替换操作，找到本源后自然就能理解了。
						
						当然还有一个办法，那就是查看预编译后的替换结果，不过这样还不如层层替换后分析本源来的更直观。
							
						分析演示：

						
						
							
						
						分析的结果总结：
							所有带参宏的宏体都指向同一个函数lock_set，通过不同的带参宏去调用lock_set函数，就实现了不同的功能，
						那为什么要这么做呢？为什么不直接定义6个加锁、解锁的函数呢？
				
				
				
			（2）为什么要费劲的写这些个复杂的带参宏？
			
					通过前面的介绍我们知道，这个程序的作用是实现对文件的加锁和解锁，可以实现的操作有：
						加非阻塞读锁
						加阻塞读锁
						加非阻塞写锁
						加阻塞写锁
						解锁
					
						其实最终是调用fcntl函数来加锁、解锁的，不过为了调用更方便，我们需要进行进一步的函数封装，其中最笨的方
					式是定义六个函数，分别是想上述功能。
						
						但是最后发现一个现象，那就是所有函数想要做的事情都是一样的，都是去设置文件锁的属性，每个函数的代码
					内容几乎一模一样，函数功能的不同仅仅只是靠参数值的不同来体现的。
						
						像这种情况，我们定义6个函数来实现，代码其实并不简洁，而且定义这些函数还很花费时间，此时我们就可以使
					用带参宏来实现，不仅减少了函数的定义，而且还简化了参数。
						
						能够写死的参数就直接在宏体中写死，调用带参宏时，只填写必须要写的参数。

						例子中这样的宏的做法在复杂的C源码中经常看见，比如我们接下来要举一个Linux驱动中的一个真实的案例，也是
					类似的情况。
						
				
				
				
				
				
				
				

出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
										
		2.5.3 例子3：Linux驱动中的真实案例 ———— module_init()带参宏
				不过为了讲清楚这个例子，我们需要先做一些知识铺垫。
			
				当然我们这里讲Linux驱动中的这个案例，实际上也是在为后面Linux驱动的课程打基础，有一定的知识铺垫后，对于大家
			后面学习驱动的课程，也是非常有帮助的。
					
					
			（1）入口函数
					1）什么是入口函数？
							入口函数就是程序启动起来后，第一个被调用的函数，这个函数就是入口函数，对于我们c应用程序来说，main
						函数就是我们自己应用程序的入口函数，我们自己写的应用代码，就是从main这个入口开始执行的，其它所有
						的子函数，都是靠这个入口函数来调用的。
						
					2）入口函数的名字怎么来的？
							比如main这个名字怎么来的，通过第1章课程的学习我们都知道，main函数是由启动代码调用的，所以入口函数叫
						什么名字，实际上是由启动代码决定的，启动代码规定这个名字应该叫wwww，那我们写main函数时main就应该写
						为wwww。
						
							对于c系的语言来说基本已经约定俗成，应用代码的入口函数大多都叫main，如果你写其它的名字，编译时就直接
						提示你没有main入口函数，没有main函数的话，启动代码根本就没办法调用我们自己写的应用代码。
						
						
						
					3）入口函数有没有不叫main
							还真有，比如win32图形界面编程，虽然图形库的接口函数都是c语言写的，但是我们在写win32的图形界
						面程序时，它的入口函数就不叫main，而是叫WinMain。
								
							演示：
							
							
							win32图形界面库是windows的基础图形界面库，windows上运行的c++、java、c#程序时，它们的图形界面库基本
						都是基于win32图形界面库进行二次封装得到的，实现图形界面时最终调用的还是windows图形界面库，不过这个情
						况在Linux这边就有所不同，这里我们不深究这个问题，只是顺带提下。
							
							
							为什么不叫main？
								实现win32图形界面库的这帮家伙就是不想叫main，他们在实现启动代码所需的.o时，人家规定入口函数就是
							叫WinMain，你还能怎么着。
					
					
					
					
					4）驱动程序的入口函数
							我们这里主要讲的是Linux驱动程序，驱动程序写完之后是需要加入Linux内核，成Linux内核的一部分，加入后
						内核就可以调用驱动程序去控制我们的硬件了，为了能够调用驱动程序，驱动程序必然也要有入口函数，以供Linux
						内核调用。
						//调用顺序
										应用程序（如果是C写的话，一般main是入口函数）
											|
											| OS API
											|
										Linux 内核
											|
										驱动程序（驱动入口函数）
											|
											|
										硬件（通过读写寄存器去控制硬件）
											
								
								Linux驱动程序的入口函数又叫什么名字呢？
									不是一个固定的名字，名字是由我们驱动开发者自己给的，只要通过module_init(驱动入口函数名)向内核
								提交这个名字，Linux内核就知道应该通过调用这个函数，去调用驱动程序了。
									
									module_init是由谁提供的？
									肯定是由Linux内核提供的，只有这样才能向Linux内核提交驱动的入口函数。
									
									为什么允许Linux驱动的入口函数可以自己命名？
									这样更人性化，你可以根据你自己所实现的驱动的用途不同，起一个更好识别的更贴切名字，可以更好的见
								名识意思。
									
									


出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
									
						5）分析module_init()宏
								module_init是一个带参宏，只不过Linux内核把它写成了小写的，不过我们说过，在我们在自己的代码
							中应该尽量将宏写成大写。
								
								
								为什么内核喜欢将好些带参宏写成小写？
								就是想让你把它看成是一个函数，或者说就是希望你把它理解为一个函数，当成一个函数来用，不过它其
							实是一个宏，但是我们还是建议，在我们自己的程序里面，宏尽可能的大写。
								
								
							
							（a）module_init()定义在了什么位置
										在/include/linux/init.h中，我们在ubuntu下是找不到这个头文件的，因为这个是Linux内核源码文件，
									ubunu的Linux内核早就被编译好了，所以ubuntu下没有Linux的源码，所以找不到这个头文件。
								
										假如我写了一个鼠标驱动程序，入口函数叫mouse_device，现在想引用module_init告诉内核，驱动的入口
									函数是mouse_device，那应该怎么做呢。
										
										很简单，引用这个带参宏来实现：
										module_init(mouse_device)	
									
									
									
									
									
						
										
							（b）分析module_init(mouse_device)	
									
									· module_init宏定义的层层嵌套的逻辑
										#define module_init(x)	__initcall(x);
										
								        #define __initcall(fn) device_initcall(fn)
																		
                                        #define device_initcall(fn)		__define_initcall("6",fn,6)
								
										#define __define_initcall(level,fn,id) \
										static initcall_t __initcall_##fn##id __used \
										__attribute__((__section__(".initcall" level ".init"))) = fn

																																						
									· 替换的过程
										module_init(mouse_device) ——> __initcall(mouse_device) ——> device_initcall(mouse_device)———
										——> __define_initcall("6", mouse_device, 6s) ————>
								
										———>static initcall_t __initcall_##mouse_device##6s __used __attribute__((__section__(".initcall" "6" ".init"))) = mouse_device
										
										
										- ##：连字符，将前后连在一起，连在一起后##就消失了，最后就演变为如下形式。
											static initcall_t __initcall_mouse_device6s __used __attribute__((__section__(".initcall" "6" ".init"))) = mouse_device
											
											有关##的作用，后面还会在讲到。
											
											
									
									· 分析最终原型
											原型中的__used __attribute__((__section__(".initcall" "6" ".init")))作用是用于指定相关属性，
											为了便于分析，我们将属性相关的内容给它省略，化繁为简暴露出核心信息，最后就得到了如下格式。
											static initcall_t __initcall_mouse_device6s = mouse_device
											
											
											- initcall_t：为typedef int (*initcall_t)(void)
													是一个函数指针类型，有关函数指针类型，我们后面在讲函数时还会讲到。
											
											static initcall_t __initcall_mouse_device6s = mouse_device
											定义一个函数指针变量，存放mouse_device的函数地址。
												等价为：
												
												
												
											static int (*__initcall_mouse_device6)(void) = mouse_device;
											
											
											
											
												这个就是最终的原型，说白了就是定义了一个函数指针变量，用于保存驱动程序的入口函数
											mouse_device的函数地址，在c语法中函数名就是函数的第一条指令的地址。
											
												内核到时候就是通过__initcall_mouse_device6这个函数指针变量，来调用驱动程序的入口函数
											mouse_device。
		
											
											__initcall_mouse_device6(参数);
											
											
											
											
											
											
											
		
									· 分析__used __attribute__((__section__(".initcall" "6" ".init")))
											
										- __used宏：在/include/linux/.h中，__used为空，其它的.h中就不一定为空了
										
										- __attribute__：这个是gcc编译器所支持的c关键字。
												表示要设置属性，具体设置什么属性，由后面的内容((__section__(".initcall" "6" ".init")))
											来决定。
												
												一般底层开发才会用到这个__attribute__关键字，如果你写的C程序只是一个应用程序的话，
											基本是看不到这个关键字的，正是由于不常见，所以很多同学刚开始看到这个关键字的时候就蒙圈了，
											因为大家大多学c的时候，写的都是应用程序，根本见不着这个关键字，所以不熟悉。
												有关这个关键字，我们后面的课程还会讲到。
											
											
										- ((__section__(".initcall" "6" ".init")))：代表具体要设置的属性。
											
											+ __section__：也是gcc支持的c关键字，基本只有底层开发才会用到c关键字，
													这个关键字的作用是，用于说明你的“驱动入口函数的代码”放到.text中的什么位置。
													
													
											+ ".initcall" "6" ".init" ：说明具体放的位置
													最简单的理解就是，表示放到内核二进制代码的.text中的.init中的.initcall中的第6个位置。
												
													图1：
													
													
													
												
												为什么要把驱动的代码放到Linux内核代码.text中？
														我们前面说过，驱动代码最后是要加入内核，成为内核代码一部分的，所以肯定是要放到内核
													代码的.text中。
																		
																		
													如果我们不设置属性，指定入口函数具体放在.text的什么位置，就会在.text中随机放，如果指
												定了，就会放到你指定的位置。
															
									

												为什么向Linux内核告诉驱动程序的入口函数时，要指定入口函数的代码在.text存放的位置呢？
													作用有很多，比如，放到指定的位置，这个指定的位置对代码的访问权限会做相应限制，有关这
												个问题，我们就到这里就不再深入，当后面Linux驱动课程涉及到后，我们再具体什么介绍。
													
													
													我们在写c应用程序，编译器编译时所有函数的代码放到.text中的什么位置，这个是由编译器的链接
												脚本自行决定的，我们不需要指定位置。
													
													
													当然我们也可以自己在代码中加以指定，编译器编译时可以放到我们自己指定的位置，但是在
												c应用程序中这么做意义不大，当然也正是由于这种用法很少见，所以大家在看内核源码、碰到这
												类东西的时候，才会蒙圈。	

								
								
										
												
							（c）回顾module_init()的作用								
									两个：
									· 第一个：告诉内核，驱动程序的入口函数的地址
									· 第二个：设置相应的属性
									
									· 第一个：告诉内核，驱动程序的入口函数的地址
											做法是定义一个函数指针变量，然后将入口函数地址保存到里面，内核即可通过这个指针变量来调用。
										指针变量的名字中有一部分就是入口函数名字。
											
											static initcall_t __initcall_mouse_device6 = mouse_device
											                            -------------    ------------
																									
										思考下：为什么内核入口函数的名字可以随便自己定？
										内核只需要拿到入口函数的地址即可，至于取什么名字，完全由驱动开发者自己来定。
										
										
										
									· 第二个：设置相应的属性
											定义函数指针变量时，通过__used __attribute__((__section__(".initcall" "6" ".init")))设置相
										关属性。
										
										
										
										
										
							（d）总结
										通过这个例子，我们可以看出，想要理解好module_init这个宏，不仅仅只是宏的问题，还涉及到
									__attribute__等关键字的问题，不过如果你连最起码的宏这一关都过不了的话，你的分析讲无从下手。
									
									
										分析这类比较复杂的宏的时候，千万不要只干眼看，一定要动手去层层替换找到本源，只要当你得到
									最本源的东西时就好办了，如果最本源的里面还有其它无法理解的东西，那就再想办法解决，但如果
									你连本源都得不到，那你一定会抓瞎。
									
										大家以后在源码中再次碰到这样的复杂宏的时候，就按照我们这里介绍的这个方法来分析，一定就
									没有问题。
										
										
							（e）疑问：为什么内核搞得这么复杂
									引用module_init时，把module_init(mouse_device)直接换成如下写法也是可以，
									
									static initcall_t __initcall_mouse_device6 __used \
									__attribute__((__section__(".initcall" "6" ".init"))) = mouse_device
							
							
									不过这个写法显然不够人性化，Linux内核必须给提供最简单的接口，比如module_init，以方便驱动开发者使用。
									

									世界上没有完美的事，这种简单的接口，虽然给“引用”带来了方便，但是却也给源码分析带来了麻烦，不过
								只要大家按照我们给的方法去分析，其实也没有什么难的。
									
							
									其实大家最终会发现，这个宏的例子，其实与我们前面讲的文件锁的那个例子非常相似
									
									· 文件锁的例子
										所有的宏最终都指向了一个东西，lock_set函数。
										
										虽然都是同一个函数，但是通过不同的参数就可以区分你想做的事情。
										
										
									· mode_init的例子
											所有的宏最终指向的也是同一个东西，那就是__define_initcall带参宏。
											moduel_init —> __initcall —> device_initcall(使用参数来区分) 
																						\ 
																						 \
																						  \
																						   V
																#define __define_initcall(level,fn,id) \
																	static initcall_t __initcall_##fn##id __used \
																	__attribute__((__section__(".initcall" level ".init"))) = fn
																					
																														 ^
																														/
																													 /
											***_init   —>   __***call   —>  ***_initcall(使用参数来区分) 
												
								
										内核通过mode_init带参宏，很好的简化了引用，减少了参数。
								
								
								
								
								
								
		2.5.4 例子3：使用宏对了类型进行自定义命名
			
			#define INT32_t int
				INT32 a;
			
			#define U32_t   usigned int 
				U32_t a;
				
			#define STUDENT_t struct info_student; 
				STUDENT stu;
				
				
				不过对类型自定义命名，最好还是使用typedef来实现，因为宏只是简单的替换，如果使用不当的话，这种简单替
			换会导致bug，有关这个问题，我们后面讲typedef时再来对比介绍。
				
				不过使用宏这种方式来实现类型自定义命名方式，冷不丁的在有些源码中还是会看见的，特别是在好些个单片机的程序
			中，这种方式还是挺多的，所以这里要了解下。
			
				疑问：为什么要对类型进行重新自定义命名？
				有关这个问题，我们讲typedef的时候再来解答。
				
			
			
		2.5.5 例子4：
			（1）offsetof宏
					#define offsetof(type, member) (size_t)&(((type*)0)->member)
			
			（2）container_of宏
					#define container_of(ptr, type, member) ({ \
						const typeof( ((type *)0)->member ) *__mptr = (ptr); \
						(type *)( (char *)__mptr - offsetof(type,member) );})
				
					
					不过这两个宏分析起来就没有那么容易了，我们将这两个例子举出来，仅仅只是想让你知道，宏这个东西在
				实际开发中的各种源码中经常看见，而且往往还比较古怪，所以希望大家能够学会适应宏的存在，学会阅读宏，理解宏。
					
					由于这两个宏与结构体相关，所以有关这两个宏的分析，我们就留在讲结构体时再来分析，
				其实分析的方法还是一样的，只是稍微麻烦些。
	
	
		2.5.6 总结
				以后大家看复杂C源码时，你还会看到很多古里古怪的宏用法，我们这里不可能都把这些例子举出来，总之
			通过这几个例子的介绍后，希望大家能够慢慢适应源码中宏的各种古怪的、复杂的用法，遇到了后希望大家
			能够按照我们介绍的方法去自行分析理解。--------------++--++---+-
		
		
		


出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			

		
3. 条件编译
		由于C++兼容C语法，所以我们这里介绍的虽然是C的条件编译，但是在C++中也是这样的。

		
		
	3.1 条件编译的作用
			其实是从“条件编译”这个名字上就能看出，所谓“条件编译”其实就是“有条件地去编译”。
			
			也就是“预编译”时，预编译器处理“条件编译”时，可以通过“条件编译”帮你保留某些代码、以及帮你去掉某些代码，
		第二阶段编译时就只编译保留的代码。
			
			一般情况下，C源程序中的每一行代码都要参加编译的，但有时候出于对程序代码优化的考虑、或者其它方面的考虑，
		我们只希望对其中一部分内容进行编译，此时就需要在程序中加上条件（条件编译），让编译器只对满足条件的代码进
		行编译，将不满足条件的代码舍弃。
			
			
			a.c
			#include <stdio.h>
			
			#define NUM1

			int main(void)
			{
				int a = 0;
				
				#ifdef NUM1
				a += 10;
				#endif
				
				#ifdef NUM2
				a += 1000;
				#endif
			}
			
			比如以上这个a.c，预编译器在对a.c进行预编译时，由于只定义了NUM1宏，没有定义NUM2宏，所以预编译后，main函数
		中只留下了int a += 10;。
			
			预编译后，main函数最后就变为了如下样子：
			int main(void)
			{
				int a = 0;
			
				int a += 10;
			}
			
			演示：
			
			如此就实现了代码的选择。
			
			
			
			
	3.2 C初学者对条件编译的误解
			对于很多C的初学同学来说，往往误认为条件编译可有可无，它是一个不重要的东西。
		
		
		（1）误解的原因
				1）初学C语言时，写的练习程序都太简单了，几乎用不到。				
				2）初学时很少阅读复杂C源码，很难接触别人写的包含大量条件编译的代码。
					很少阅读的原因，一个是因为没有工作环境的支持，你阅读不到；第二个就算接触到了，你也根本看不懂。

					
			2）除了复杂宏定义外，其实条件编译也是阻碍我们阅读复杂C源码的难关之一。
					
					在复杂的C代码中，往往到处都充满了条件编译这个东西，如果你搞不定条件编译，你很难读懂复杂的
				C代码，但是在实际与C相关的开发中，阅读复杂的OS、库、驱动、框架代码确又是家常便饭的事情。
					
					

		
	3.3 为什么条件编译在实际开发中这么重要

			因为实际开发的C程序，往往因为各种原因，需要在同一个程序中编写出针对不同情况（比如不同OS、硬件环境）的代码，
		编译程序时为了编译得到针对不同情况的可执行程序，我们需要使用条件编译来做选择。
		
			当然程序中并不是所有的代码都需要使用条件编译来选择，只有哪些需要被选择的代码，我们才会对其使用条件编译。
			
			
		疑问：为什么不直接全部编译呢？
			这样子会导致我们的可执行程序非常大，因为里面不仅包含了我们需要的代码，还包含了很多用不到的代码。
			但是使用条件编译将不需要的代码去掉后，就不存在这样的情况了。
			
			程序变小之后，程序不管是静态存储在硬盘上，还是运行在内存中时，将会非常节省计算机的硬盘空间和内存空间。
			
			特别是当你的程序非常庞大时，又或者是当你的计算机资源本来就不是很足时，这一点就显得更重要了。
			
			
			
	3.4 什么情况下需要使用条件编译？		
			
		（1）文件内容被重复include时，去掉重包含的内容
		（2）实现程序的跨平台
		（3）辅助调试程序
		
			有关这三种情况，我们后面再详细说。
			
			
			
			
			
			
			
			
	3.5 常见的条件编译有哪些，基本用法是怎样的
		
		3.5.1 条件编译种类概述
			
			（1）对于条件编译，关键是理解而不是死记硬背
						只要你理解了，就算忘了怎么写了，上网上一查便知。
		
		
			（2）条件编译种类
					条件编译主要有两种：
					
					1）第一种：#ifdef、#ifndef
						（a）ifdef：if defined的缩写
						（b）ifndef：if ndefined的缩写
									由于#ifndef的功能与#ifdef刚好相反，所以只要理解了#ifdef，就一定能理解#ifndef。
						
								为了面对更复杂的情况，#ifdef、#ifndef往往还会和#else的搭配。
						
						
					2）第二种：#if 
						为了得到更复杂的用途，#if往往会和defined、#elif、#else的搭配。
						#elif：else if的缩写，类似c语法中的else if
	
					
			（3）注意
					1）不管那种情况，结尾时都是必须使用#endif结尾，这是固定格式。
						#ifdef ***         #if ***
						...                ...
						#endif             #endif
						
						#endif表示结束该条件编译。
						
						
						#ifdef、#if 好比{
						#endif      好比}
						必须配对使用。
						
						
						
					2）条件编译所包含的可以是任何内容
					
							你需要对什么进行条件编译，条件编译就可以包含什么内容，这个是根据你自己需求来定的。
							
						（a）可以是#include <***>
								#ifdef ***   
								
								#include <****.h>
								#include <****.h>
								...

								#endif
								
								
						（b）整函数
								#ifndef ***    
								int fun(int a, int b)
								{
									...
								}
								
								#endif
								
								
						（c）函数内部的部分代码
								int fun(int a)
								{
									#if ***
									int b = 100;
									...
									
									#else
									...
									
									#endif
									...
									...
									...
								}
						
						（d）类型定义，变量定义
								#if ***
								struct student
								{
									#ifdef ***
									int num;
									...
									#endif
									...
								};
								
								struct student stu;
								int gbl_va = 100;
								
								#endif
						
						（e）整个文件的内容
								stdio.h
								
								#ifndef _STDIO_H_
								...
								...
								//整个头文件的内容
								
								
								#endif
								
					
					3）#elif、#else、defined等，只能与#if #ifdef搭配使用，不能独立使用
						（a）错误的写法
								比如：
								#elif ***
								...
								#endif
								
								#else 
								...
								#endif
						
						
						（b）正确写法
								比如：
								#if ***
								...
								#elif
								...
								#else
								...
								#endif
								
 								#ifdef ***
								...
								#else
								...
								#endif
								
						
						为了简单期间，我们再给大家演示条件编译如何使用时，我们只在.c文件中演示，但是实际上在.h文件中，条
					件编译的使用是一样的，因为.h中的内容被包含到.c中后，其实还是变成了.c的一部分。
					
					
					
					
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
								
					
			3.5.2 #ifdef、#ifndef		
				
				（1）基本格式
						1）格式
							· #ifdef
	
								#ifdef 宏 
								...
								#endif
							
									#ifdef是以宏存不存在（有没有定义）来判断真假的，如果宏
									存在：真，保留代码
									不存在：假，不保留代码
									
							· #ifndef
								
								#ifndef 宏 
								...
								#endif
								
									情况刚好与#ifdef相反，如果宏
									不存在：为真，保留代码；
									存在：为假，不保留这个代码。
									
									
						2）例子
							#define WINDOWS_XP   //这是一个无宏体宏
							
							#ifdef WINDOWS_XP
							printf("procedure word needed by windows_xp\n");
							#endif
							
							#ifndef LINUX
							printf("procedure word needed by Linux\n");
							#endif
							
							演示：
.i
int main()
{

    printf("procedure word needed by windows_xp\n");



    printf("procedure word needed by Linux\n");

}
	
							
							疑问：可不可以给#ifdef 指定有宏体的宏？
							当方可以，
							#define WINDOWS_XP   0
							
							#ifdef WINDOWS_XP
							printf("procedure word needed by windows_xp\n");
							#endif
							
							这里指定宏体没有太大意义，因为#ifdef和#ifndef是靠判断宏是否存在来判断真假的。
							
							
							
				（2）搭配#else
						1）格式
							#ifdef 宏  //#ifnedf 宏
							...
							...
							#else
							...
							...
							#endif
							
							二选一。
							
						2）例子
							#ifdef WINDOWS_XP  //#ifndef WINDOWS_XP
							printf("procedure word needed by Windows_xp\n");
							
							#else
							printf("procedure word needed by Linux\n");
							
							#endif
							
							演示：
							.i
							int main()
							{

								printf("procedure word needed by Windows_xp\n");





							}
							
				（3）与#elif
						
						错误写法
							
						#ifdef ***
						...
						
						#elif #ifdef
						...
						
						#endif
						
						这个是错误的写法，#elif #ifdef会导致在一行里面有两个预编译关键字，我们我们前面说过，在每行只能有一个
					预编译关键字
				
				
					正确写法：
						#ifdef ***
						...
						
						#elif 1 // NUM == 100
						...
						
						#endif
					
					
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------	
				
			3.5.3 #if
				（1）基本格式
						#if 表达式
						...
						
						#endif
						
							表达式为真：保留代码
							表达式为假：不保留代码
							
							#if后的“表达式”有两种：
							第一种：为整形常量，或者整形常量表达式
							第二种：为由defined、!defined组建表达式
							
							
							
						1）第一种：表达式为整形常量
							（a）格式
										#if 整形常量，或者整形常量表达式
										...
									
										#endif
										
										表达式为真：保留代码
										表达式为假：去掉代码
										
							（b）例子
									#if 1 //1为真（非零为真），保留代码
									...
									
									#endif
									
									
									当然也可以定义成宏
									
									//不保留
									#define NUM 0  
									
									#if NUM 
									...
									
									#endif
									
									
									
									//不保留
									#define NUM 0
									
									#if NUM == 1  // 写>  <   >=  <=这些符号都是成立的
									...
									
									#endif
									
									可不可以把宏体去掉，#define NUM 0变为#define NUM？
									答：不行，if需要用到NUM的宏体的数值判断真假。
								
							
							
						2）第二种：表达式由defined、!defined组建
								
							（a）#if defined
									· 基本功能
										- 与#ifdef是一样的，这个时候是通过判断宏存不存在来判定真假。		
													
										- 例子
											#define MACRO
										
											#if defined MACRO //如果定义了这个宏（宏存在），就保留代码
											printf("1111111\n");
												
											#endif
											
											
									· 与#ifdef不同之处
									
										- #ifdef是独立的关键字，但是#if defined是两个两个关键字的组合
										
										- #if defined可以实现宏的“&&、||”运算，但是#ifdef不行 
											#define MACRO1 
											#define MACRO2
											
											
											#if defined MACRO1 && defined MACRO2  //如果这两个宏都定义了的话，才保留代码
											printf("1111111\n");
											
											#endif
											
											
											
											
							（b）#if !defined
									!和defined是两个独立的关键字。
								
									· 功能与#if defined刚好相反，
											宏不存在：为真
											宏存在：为假
									
									
									· 例子1
											#define MACRO
											
											#if !defined MACRO //如果没有定义这个宏（宏不存在），就保留代码
											printf("1111111\n");
													
											#endif
									
									
									· 例子2
											#define MACRO1 
											#define MACRO2
											
											//只有当这两个宏都没有定义时，才保留代码
											#if !defined MACRO1 && !defined MACRO2
											printf("1111111\n");
											
											#endif
											
											
									· defined和!defined也可以混用
											#define MACRO1 
											#define MACRO2
											
											#if (defined MACRO1 && defined MACRO2) || !defined MACRO3
											printf("1111111\n");
											
											#endif											
											
											可以按照你自己的要求随意的组合。											
																							
									
									
				（2）与#else 搭配
						直接举例讲解。
						
						
						1）例子1：
								#define NUM 0
								
								#if NUM              //0为假，不保留代码
								printf("1111111\n");
								
								#else 
								printf("2222222\n");
								
								#endif
							
							
						2）例子2
								#define MACRO1 
								#define MACRO2
								
								#if !defined MACRO1 && defined MACRO2
								printf("1111111\n");
								
								#else                //如果前面的条件不成立，就保留#else后面的代码
								printf("2222222\n");
								
								#endif
							
							
				（3）与#elif 搭配
							直接举例演示。
							
						1）例子1
							#if 1
							printf("1111111\n");
							
							#elif 1
							printf("2222222\n");
							
							#endif
							
							
						2）例子2
							#if !defined MACRO
							printf("1111111\n");
							
							#elif defined MACRO1
							printf("2222222\n");
							
							#endif
						
						
						3）例子3
							#if 0  //#if !defined MACRO
							printf("1111111\n");
							
							#elif NUM == 100
							printf("2222222\n");
							
							#elif !definedMACRO1 || defined MACRO2
							printf("3333333\n");
							
							#else  //#else可以没有
							printf("4444444\n");
							
							#endif
							
							
						#if、#elif、#else、!、defined这些关键字怎么组合使用，完全取决于你自己的想要怎么用。
							
		
		
		3.5.4 大略的看下别人源码文件中用到了哪些条件编译
			

	
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
	
	3.6 条件编译书写时的排版问题
	
		3.6.1 什么是条件编译的排版？
				就是#if、#elif、#else、#endif关键字的对齐、缩进等等，这些就是“条件编译”的排版。
				
				
		3.6.2 为什么介绍条件编译的书写排版？
				两个原因：
			
			（1）写出更容易阅读的条件编译。

						与{ ... }的这种书写方式对比起来，条件编译的#if ... #endif的这种书写方式不太容易阅读，此时如果你
					又不注意排版问题，就会使得阅读变得很糟糕。

						
			（2）了解了排版规则后，有利于理解别人写的条件编译
				
					
		3.6.3 条件编译的排版
		
			（1）条件编译没有互相嵌套时
					
					所有条件编译关键字语句顶格左对齐。
					
					#if 0
					...
					#elif  1
					...
					#endif
					
					
					#ifdef NUM 
					..
					#else 
					...
					#endif
					
			
			（2）如果条件编译之间有嵌套时
						嵌套的条件编译需要进行缩进，如果里面有包含#define、#include的话，define、include也需要缩进。
						
						我们举两个stdio.h中的真实案例。
					
					1）例子1 
							#if !defined __need_FILE && !defined __need___FILE
							# define _STDIO_H       1
							# include <features.h>

							__BEGIN_DECLS//已经定义好，在这里引用的一个宏 

							# define __need_size_t
							# define __need_NULL
							# include <stddef.h>

							# include <bits/types.h>
							# define __need_FILE
							# define __need___FILE
							#endif /* Don't need FILE.  */
							
							注意缩进方式，#是不用缩进，#和define、include中间隔有空格是没有问题的。

							通过所缩进可以非常明显的看出包含关系和配对关系。
							
							不过这个例子中没有嵌套其它的条件编译。
							
						
					2）例子2
							#if defined __USE_XOPEN || defined __USE_XOPEN2K8
							# ifdef __GNUC__
							#  ifndef _VA_LIST_DEFINED
							typedef _G_va_list va_list; //正常代码（非预编译代码），不需要缩进
							#   define _VA_LIST_DEFINED
							#  endif
							# else
							#  include <stdarg.h>
							# endif
							#endif

								这个例子中条件编译就存在非常复杂的嵌套关系，如果不进行缩进的话，你将会完全无法理清配对关系，
							如果无法理清配对关系，自然你也就无法理清这些条件编译的逻辑关系，阅读类似这样的源码时，你直接就
							发蒙了。
							
								通过这个例子我们可以感受到，如果你不清楚条件编译的排版的话，当你看到这些玩意时会很头晕。
							
								
							
			（3）条件编译在函数体外时
			
					条件编译关键字语句顶格左对齐。
					Linux内核源码的例子。
					
					1）例子1：
						#if defined(CONFIG_FB_SIS_300) || defined(CONFIG_FB_SIS_315)
						static void
						SiS_ShortDelay(struct SiS_Private *SiS_Pr, unsigned short delay)
						{
							 while(delay--) {
									SiS_GenericDelay(SiS_Pr, 66);
							 }
						}
						#endif
					
						只有里面包含的函数代码无需缩进，正常格式写即可。
					
					
			（4）条件编译在函数体内时
						没有嵌套时定格左对齐即可。
						
						void SiS_IsVAMode(struct SiS_Private *SiS_Pr)
						{
						#ifdef CONFIG_FB_SIS_315
							 unsigned short flag;

							 if(SiS_Pr->ChipType >= SIS_315H) {
									flag = SiS_GetReg(SiS_Pr->SiS_P3d4,0x38);
									if((flag & EnableDualEdge) && (flag & SetToLCDA)) return true;
							 }
						#endif
							 return false;
						}
												
						如果有条件编译嵌套的话，按照之前讲的进行缩进即可。
						
											
						
		3.6.4 是不是学会了条件编译关键字以及排版问题，就一定能看懂源码中的条件编译了呢？
				
				当然不是的，如果想看懂某个条件编译想干什么，还有一个关键就是要能看懂“条件编译”的判断条件。
					
					#if defined(CONFIG_FB_SIS_300) || defined(CONFIG_FB_SIS_315)
					static void
					SiS_WaitRetrace2(struct SiS_Private *SiS_Pr, unsigned short reg)
					{
						 unsigned short watchdog;

						 watchdog = 65535;
						 while((SiS_GetReg(SiS_Pr->SiS_Part1Port,reg) & 0x02) && --watchdog);
						 watchdog = 65535;
						 while((!(SiS_GetReg(SiS_Pr->SiS_Part1Port,reg) & 0x02)) && --watchdog);
					}
					#endif
					
					
						想要理解条件编译#if defined(CONFIG_FB_SIS_300) || defined(CONFIG_FB_SIS_315)，你需要理解
					CONFIG_FB_SIS_300和CONFIG_FB_SIS_315宏。
						
						如果想要理解这两个宏的话，这就与源码逻辑有关了。
						
						
						但是#if、#ifdef等条件编译关键字，以及条件编译的排版是基础，你连这个基础都不行，想要弄懂源码中的条
					件编译那就更不容易了。
					
					
					疑问：分析源码时，是不是源码中所有的条件编译代码都需要搞明白呢？
					当然不是的，根据你自己阅读源码的需要，搞明白必须要弄明白的条件编译即可。
					
				
				
		3.6.5 再说下有关条件编译的缩进	
			在有些源码中，条件编译缩进可能是如下样子。
			
			#if defined __USE_XOPEN || defined __USE_XOPEN2K8
				#ifdef __GNUC__
					#ifndef _VA_LIST_DEFINED
					
			typedef _G_va_list va_list; //正常代码（非预编译代码），不需要缩进
						
						#define _VA_LIST_DEFINED
					#endif
				#else
					#include <stdarg.h>
				#endif
			#endif
			
			
				不管是前面介绍的缩进方式，还是目前这种缩进方式，其实都可以，这两种缩进方式，不同的源码都有使用，
			至于我们自己使用哪种，可以跟着当前你自己所使用源码的风格走，也可以根据自己的喜好走。
			
	

出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
	
	3.7 具体是什么时候会用到条件编译呢
			前面介绍过，大致用在三类地方：
				
		（1）文件内容被重复include时，去掉重包含的内容
		（2）帮助我们的程序的跨平台
		（3）辅助调试程序
				
				
		3.7.1 文件内容被重复include时，去掉重包含的内容
		
				我们以include 头文件来举例介绍，当一个C/C++工程文件写复杂后，在一个.c/.cpp中往往可能会包含十几个头文件，
			误操作使得同一个头文件重复包含多次，这其实是很正常的。
				
				重复include的话，预编译器处理#include时，会把同一个头文件的内容重复的复制（包含）到.c中，但是我们知
			道头文件中往往会有struct ***等类型的定义，重复包含后，会导致在同一个.c中有重复的结构体类型定义，我们在
			第一章就说过，在同一个c文件中不能有重复的类型构体定义，第二阶段编译时，会报重复定义的错误。
				
				但是实际上我们在重复inlcude同一头文件时，并没有报错误，那是因为头文件中加入了#ifndef条件编译，
			所以说#ifndef其中有一个很重要的用途就是用于防止文件被被重复包含。
			
			（1）以C标准库的头文件stdio.h头为例
					1）windows下stdio.h
					
						#ifndef _STDIO_H_
						#define	_STDIO_H_
						
						//头文件的内容
						...
						
						#endif //头文件的结尾
						
						
					2）Linux下的stdio.h头文件
						#ifndef _STDIO_H
						#define _STDIO_H       1 
						
						//头文件的内容
						...
						
						#endif
						
						
						疑问：都是stdio.h，但是它们的宏咋不一样呢，一个叫_STDIO_H_，_STDIO_H？
						答：如果你仔细阅读这两个stdio.h的话，你会发现这它们里面的内容也不一样，这个并不奇怪，说明它们是由
						不同团队编写的，一个是用在windows这边，另一个是用在Linux这边。
						
							尽管二者内容有所区别，但是所要实现的事情都是一样的，不然的话你在Liunx下c程序调用了printf函数，
						结果这个程序到了Windows就不能调用printf了，这就扯淡了。
						
						
						疑问：宏的头尾怎么都带_呢？
							这个是库、OS的标识符的命名习惯，目的是方便识别，因为你一看到带_打头和结尾你就知道，那一定是库、
						或者OS等标识符。
							
							我们自己的应用程序尽量不要使用这种命名格式，以便与库、OS、框架等的标识符进行区别。
							
						
					3）使用#ifndef来防止文件重复包含的原理
						举例理解，比如：
								a.c
								#include <stdio.h>
								#include <stdio.h>
								
								
								int main()
								{
									...
								}
								
								
								
						（a）第一步：预编译器到相关路径找到include所指定的.h文件，然后将所有.h文件中的内容复制到a.c中，替换掉
								#include <***.h>
								
									注意，重复的.h的内容会被全部复制到.c中。
									
									a.c 
									/* stdio.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
									
									头文件的所有内容
								
									#endif
									
									/* stdio.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
								
									头文件的所有内容
								
									#endif
									
									
									
									int main()
									{
										...
									}
									
						
						（b）第二步：处理条件编译，去掉重复的内容
								口述：
								
								
								
								#ifndef的原理很简单，其实就是先重复包含内容，然后再通过#ifndef将重复的内容去掉。
							
							
					4）说说“防止头文件内容重复宏”的命名
						
						
						（a）不同的头文件中该宏的宏名是不相同的
						
								如果相同的话，就会导致其它头文件无法正常被包含。
								
								比如：假如stdio.h和stdlib.h中“防止文件内容重复的宏”相同的话。
									
									/* stdio.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
								
									...
								
									#endif
									
									
									/* stdlib.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
								
									...
								
									#endif
										
										当相同时，第一次包含stdio.h时会定义_STDIO_H_，包含stdlib.h时发现这个宏已经被定义了，
									导致stdlib.h的内容被丢弃。

						
						（b）如何防止宏名冲突呢？
								每个头文件的文件名基本都会不相同的，所以只要你在宏名里面参入文件名，就一定不会重名。
							比如对于我们自己写的头文件来说，可以按照如下方式命名这个宏。
								
								比如：
								student.h
								#ifndef H_STUDENT_H
								#define H_STUDENT_H
								
								...
								
								#endif
							
								或者命名为：STUDENT_H_INCLUDED
								
								你也可以有你自己的自定义命名方式，不管你怎么命名，只要名字中包含“文件名”，该宏不会重名。
								
								当然，如果是使用IDE来创建头文件的话，IDE会自动根据你的头文件名字生成该宏，IDE也会提示你，你可以
							自己修改，但是如果你是使用存文本来编写.h的话，这个宏就需要我们自己定义了。
					
								
				
				
				
				
	
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
			
			#ifndef
				
		（2）条件编译作用2 ———— 帮助我们的程序（c/c++）实现跨环境（平台）
					
					我们在正式介绍之前，我们先了解下有关“跨平台”是怎么回事。

					
				1）什么是跨平台
						所谓的跨平台，就是让“同一个程序”能够应对多个环境，可以在多个环境下运行，
					这就好比两栖战车，既能在水上环境跑，又能在陆地跑，能够适应不同环境。
						
						这个“环境”主要包含两个方面，一个软件系统环境，另一个是硬件系统环境，
				
				
					（a）软件系统：主要指OS
							比如有的是windows的，有的是unix的。
							不同的系统本身又分为了很多不同的版本，比如以windows为例，有xp、w7、w8、w10等，unix和Linux自然也存
						在类似的情况。
						
					
					（b）硬件系统：主要指cpu
							比如有的是Intel的，有的是AMD的，有的是ARM的，同一类型下的CPU也分为不同的版本（架构）。				
					
						
						程序跨环境时，环境主要指的就是这两方面。
						
						· 裸机程序跨环境：跨的是硬件环境
							比如这个程序本来是在某个CPU上运行的，现在要到另一个CPU上运行，这时程序就涉及到跨硬件环境运行。
							
							
						· 非裸机程序跨环境：软件系统和硬件系统环境都涉及
							非裸机程序，指的就是需要基于OS运行的程序。
							
								比如本来是在ARM（CPU） Linux（os）上运行C程序，现在要到Intel(cpu) windows（OS）上运行，跨环境时，
							即垮了硬件环境，又跨了软件环境。
						
						
						
				2）不同语言所写的程序，是如何实现跨平台的？
						语言大致分为两类，编译型语言和解释型语言，不过有关更详细的介绍，请大家看我们的
						
						《计算机体系结构——编译器》
						《计算机体系结构——解释器》
						《计算机体系结构——语言、算法》
							的课程。
					
						不过我们这里因为课程的需要，也简单回顾下。
						
						
					（a）编译型语言
					
							· 什么是编译型语言？
									如果语言所写的程序能够被直接编译为对应环境的、被cpu直接运行的机器指令
								(存放在了可执行文件中)的话，那么像这类的语言就是编译型语言。
													
													
													编译型语言所写的程序
															  /    \
															 /      \
															/        \
										 针对windows、Intel /  编译     \ 针对Linux、ARM
											   环境的编译器 /            \ 环境的编译器
														 /              \
														/                \
													   /                  \
													a.exe                a.out
													windows		         Linux    OS
													Intel                ARM      CPU
														                   
														
										编译型语言哪些：汇编、c、c++、Delphi、Pascal等都是编译型语言。
														
														
							· 如何实现“编译型语言程序”的跨环境？
							
										从上图看出，对于“编译型语言程序”来说，跨环境的核心靠的是编译器，你想让程序在不同的环境上运行，
									就需要使用针对不同环境的编译器来重新编译。
										
									
									疑问：对于编译型语言所写程序的跨环境来说，是不是只要换一个针对不同环境的编译器就可以了？
										
										如果不需要修改源码的话，直接换一个编译器就可以了，但是如果需要修改源码的话，就需要先修改源码，
									然后再使用不同环境的编译器来重新编译。
										
										我们这里介绍使用“条件编译”来实现c/c++跨平台，其实就与C/C++跨平台时源码的修改有关。
										
										修改源码、然后编译得到不同环境的可执行程序，其实就是我们常说的移植的过程。
					
					
					（b）解释型语言
								Java、JavaScript、VBScript、Perl、Python、Ruby、C#等都是解释型语言，你想知道某门语言是编译型的
							还是解释型的，自己上网搜索一下就行了。
							
					
							· 什么是解释型语言
									
									如果语言所写程序需要被“虚拟机(解释器)”解释才能执行的话，这类语言就是解释型语言。
									
									java就是典型的解释型语言，所以我们这里就以java为例来详细的介绍下解释型语言。
									
									
									java程序被编译后，所得到的并不是可以被直接运行的机器指令，而是一些java字节码（java伪指令），
								这些字节码放在了.class字节码文件中，我们编译java程序时所看到的各种.class文件，就是这么来的，
								运行java程序时，运行的也是.class文件。
								
									运行.class文件时，其实就是运行里面存放的字节码，但是字节码不是机器指令，不能被CPU直接执行，
								因此字节码需要被“虚拟机”解释（翻译为）为机器指令后，CPU才能执行。

									虚拟机：就是一个翻译软件，将字节码翻译（解释）为对应环境的机器指令，虚拟机也被称解释器。
										不过要注意的是，虚拟机在翻译时是一句一句进行的，也就是每翻译一句CPU就执行一句，并不是一次性
									翻译完毕，然后再一次性执行。
									
															java文本程序
																	|
																	| 编译
																	|
																	V
														 java字节码程序
																 / \
																/   \
															   /     \
															  /       \  
														     /         \
														    /           \
													       /  			 \  									
										              Windows JVM      Linux JVM     虚拟机：应对不同环境，虚拟机将字节码解释为真正的机器指令，然后运行
										              windows           Linux        OS
											          Intel             ARM		     CPU		
								
									
									有些解释型语言所编写的程序是被直接解释的，都不用被编译为字节码。
												
									
							· 解释型语言所写的程序，是如何实现跨平台？
							
									从java的运行模型中可以看出，解释型语言实现跨环境的核心靠的是虚拟机。
									
									在java的世界里有一句名言，“叫做一次编译到处运行”，只要在相关环境中安装了该环境的java虚拟机，
								之前所编译好的同一份java字节码文件可以在不同环境的虚拟机上运行。
								
									总之，对于解释性语言所写的程序来说，跨环境靠的是虚拟机。
									
									疑问：虚拟机是“编译型语言”写的，还是“解释型语言”写的？
									
									答：肯定是编译型语言写的，如果虚拟机是由解释型语言写的，那么虚拟机这个软件在运行时，又需要另
									一个虚拟机来解析，如此这就陷入了一种死循环。
									
										其实有好些个虚拟机，基本都是使用c/c++来实现的。
									
								
							
					（c）编译型语言 与 解释型语言的对比
					
							· 跨平台性
							
								- 解释型语言的跨平台
									解释型语言的跨平台性相对会更好些，因为可以一次编译到处运行，跨平台这件事完全交给虚拟机就可以了。
									
									
									疑问：安装虚拟机这个软件会不会很麻烦吗？
										现在很多的OS会自带常见的虚拟机，比如java虚拟机、c#虚拟机，就算OS没有自带也不需要用户自己安装，
									比如以java虚拟机为例，别人在发布java程序时，一并就带了java虚拟机，安装java程序时会自动安装java
									虚拟机。
									
										所以对于用户来说，虚拟机这个软件完全是透明的，用户完全不需要关心。
						
									
								- 编译型语言的跨平台
										编译型语言所写程序的跨平台性稍微比较差些，因为你必须使用针对不同环境的编译器来重新编译，而且
									有时可能还需要修改源码。
										
										从以上的对比可以看出，解释型语言与编译型语言相比来说，解释型语言的跨平台性更好些。
										
										
							
							· 运行效率
									编译型语言的运行效率更高，因为编译型语言所写的程序，会被一次性编译为对应环境的、可以被直接执
								行机器指令，而不需要运行额外的虚拟机来解释，所以效率自然高。
		
		
		
									解释型和编译型语言各有优缺，各有属于自己的应用场合，很多人喜欢过分的夸大解释型语言的优点，
								认为除了解释型语言外，其它编译型语言都是多余的，都是垃圾，这种想法是不对的。
									
									别的不说，最起码一点，如果没有“编译型语言”所写“虚拟机”的话，解释型语言所写的程序就不可能被解释，
								所以说编译型语言和解释性语言，各有各的应用场合，在各自的应用场合下，各自都有不可替代的作用。
									
									疑问：有关编译型语言和解释型语言的应用场合？
									答：请看“《计算机体系结构——软件篇》语言、算法”的课程。
									
						
						
								总结：
								解释性语言：跨平台性更好，但是运行效率相对较差；
								编译型语言：跨平台性较差些，但是运行效率会更好些。
					
						
								
						
						
						
						
	
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
												
				3）c/c++程序如何实现跨平台
						c/c++属于典型的编译型语言，跨平台时大致分两种情况。
						
						第一种：跨平台时不需要修改源码
								直接换一个针对另一个环境的编译器来重新编译即可。
							
						第二种：需要修改源代码
								先修改源代码，然后再换编译器实现重新编译。
							
							
						（a）第一种：不需要修改源码，直接换一个环境的编译器重新编译
									
								· 什么样的C/C++程序跨平台时，不需要修改源码
										只要程序不包含“平台差异代码”，包含的都是“通用代码”的话，跨平台时，不需要修改源码。
									
									
									疑问：什么样的代码是“通用代码”?
										如果代码是如下两种情况的话，就是通用代码。
										
									- 代码只涉及c/c++基本语法
										只要不同环境支持该语言，那么基本语法都是支持的。
									
									- 当代码调用了库函数时，只要该库是不同平台都支持的通用库的话，调用库函数的代码也是通用代码
											比如C标准库就是一个通用库，windows、Linux、Unix等OS都支持，所以在程序中调用c标准库的
										printf函数时，不管是windows、Linux、unix都支持，所以跨平台时printf函数不需要修改。
											
									
								· 例子
											#include <stdio.h>
											
											int main(void)
											{
												int a = 100;
												
												/* 只与基本语法归相关的代码 */
												while(1)
												{
													a = a + 10; 
													if(a==100) break;
												}
												
												printf("a = %d\n", a); //不同环境都支持的通用库函数接口
												
												
												return 0;
											} 
											
											以上这个是通用代码，跨平台时不管是在windows下、还是在Linux下运行，这个通用代码时不需要
										修改源码的，换编译器重新编译即可。
											演示：
											

											
																 C应用程序
																		|
																		|
																	库API(通用库)
																	/   \
																   /     \  
														          /       \
												                 /         \
												              C标准库     C标准库     都支持printf
                       	                                       |            |
														       |OS API      |OS API
														       |            |
												            Windows      Linux											
                                                            硬件(CPU等)	 硬件(CPU等)		 							
												
												
												由于C标准库几乎被大多数的OS支持，所以C程序中有printf、scanf、malloc等时，不管在什么平
											台下都能用，跨平台时不需要修改。
											
												如果平台不支持你要的库，但是你还想用，你就必须自己来搞定这个库，有两种搞定方法，
											第一种：在该环境下安装对应的库
											第二种：直接将库和“可执行程序”放在一起，发布程序时一起发布
												
					
									
						（b）第二种：需要修改源码								
									跨平台时为了减少麻烦，我们建议在程序中最好尽量只写通用代码，如此一来跨平台时源码就不用修改了。
									
									但是问题是，有些时候只能做到80%~90%是通用代码，程序中有10%~20%的与平台相关的代码。
									
									比如因为某些特殊原因，C程序中需要直接调用OS API，但是不同的OS的OS API又有区别，与OS API相关的
								代码就是典型的平台相关的代码。
				
									
									这里以windows、Linux为例，为了让我们的C/C++程序能够很好的面对windows、Linux，有如下两种解决办法：
								第一种：写两份独立的功能完全相同的程序，一份专门针对Windows，另一分专门针对Linux
								第二种：只写一份代码，使用条件编译来处理平台相关的代码。
									
								· 写两份独立的C程序，一个针对Windows，另一个针对Linux
									
									
									- 在windows下运行的C程序
	
										#include <windows.h>  //windows OS API所需的头文件

										int main(void)
										{
												/* 通用代码 */
												int i = 0;

												while(1)
												{
														if(i>100) break;
														else i++;
												}

												/* 平台相关代码：windows的操作文件的OS API */
												HANDLE hfile = CreateFile(".\file", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE \
												| FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
												int dwRead = 0;
												WriteFile(hfile, &i, sizeof(i), &dwRead, 0);   //将i写到file中

												return 0;
										}
		
																		windows环境编译器
										windows的C程序 ————————————————> 在windows下的可执行程序
										
									
								
									- 在Linux下运行的C程序
	
										/* Linux的OS API所需的头文件 */
										#include <sys/types.h>
										#include <sys/stat.h>
										#include <unistd.h>
										#include <fcntl.h>

										int main(void)
										{
												/* 通用代码 */
												int i = 0;

												while(1)
												{   
														if(i>100) break;
														else i++;
												}   
												
												/* 平台相关代码：Linux的操作文件的OS API */
												int fd = open("./file", O_RDWR | O_CREAT, 0774);
												write(fd, &i, sizeof(i));  //将i写到file

												return 0;
										}
						
									
															  Linux环境编译器       
									Linux的C程序 ————————————————> 在Linux下的可执行程序
								
								
										
								· 这种方式的缺点：
										由于%80~%90都是相同的通用代码，仅为了那一点平台相关代码的不同，就要写两份独立的程序，显然是
									不是很合适，最起码很浪费时间，如果写一份就能搞定的话，这是最好的。
									
										不过如果80%的代码都是平台相关代码，只有20%是通用代码的话，此时写两份完全独立的程序其实更划算。
											
								
								
							· 只写一份代码，使用条件编译来兼容。					
									这里举一个非常简单的例子，这个例子不具有实用性，但是确实能够说明说明“条件编译”对于跨平台的重
								要性。
										
									#define WINDOWS

									#ifdef WINDOWS
									# include <windows.h>
									#elif defined LINUX
									# include <sys/types.h>
									# include <sys/stat.h>
									# include <unistd.h>
									# include <fcntl.h>
									#endif


									int main(void)
									{
											/* 通用代码 */
											int i = 0;

											while(1)
											{
													if(i>100) break;
													else i++;
											}


									#ifdef WINDOWS
											/* 平台相关代码：windows的操作文件的OS API */
											HANDLE hfile = CreateFileA(".\file", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE \
													| FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
											int dwRead = 0;
											WrieFile(hfile, &i, sizeof(i), &dwRead, 0);   //将i写到file中

									#elif defined LINUX
											/* 平台相关代码：Linux的操作文件的OS API */
											int fd = open("./file", O_RDWR | O_CREAT, 0774);
											write(fd, &i, sizeof(i));  //将i写到file中

									#endif

											return 0;
									}
									
								- 修改代码中的宏，然后通过“条件编译”来保留对应平台的代码
								- 使用对应平台的编译器来重新编译
									
									在真实开发中修改源码时，其实不仅仅只会打开和关闭条件编译，有时还需要修改代码中其它相关数据。
									
								
				4）java有条件编译吗，java程序跨平台时需要修改源码吗？
				
						前面说过，只要环境安装了java虚拟机，java只需要一次编译即可到处运行，通过“只需要编译一次”的这句话
					我们就能感觉到，java程序跨平台时，其实不需要修改源码。
						
						
						
						为什么java程序跨平台时不需要改源码？
						
							因为在java程序的代码中涉及的通用代码，没有平台相关的代码，跨平台完全由“虚拟机”来完成，总之java被设计
						为了一种跨平台性非常好的语言。
						
							正是由于java是一个跨平台性非常好的语言，所以当初借鉴C来设计java时，设计者果断去掉了C中“条件编译”，
						总之这里就是想告诉大家，java是没有条件编译这个玩意的，不过有类似可以模拟“C条件编译”东西。

				
			
				5）再举一个跨平台的例子 —— 跨芯片
						我们前面举了跨OS这个平台的例子，我们现在举一个跨“芯片”这个平台的例子，那么我们举什么例子呢？
						我们这里举一个ST（意法半导体）的STM32标准库的例子，标准库为了同时支持STM32F427_437xx、
					STM32F429_439xx、STM32F40_41xx等系列芯片，大量的用到了条件编译。
						
						之所以让库同时支持这么多系列的芯片，主要是为了减少开发成本，因为如果针对每个系列的芯片都开发一个
					库的话，ST开发标准库的工程师非吐血不可，所以具有极高相似性的系列芯片，都使用同一个库，肯定是明智之举。
						
						库中80%的是通用代码，剩余20%则为与“不同系列芯片”相关的差异性代码，这些差异性代码则通过“条件编译”来选择，我们这里
					举一个库函数例子：
					
						void SystemCoreClockUpdate(void)
						{
							/* 通用代码 */
							/* Get SYSCLK source ----*/
							tmp = RCC->CFGR & RCC_CFGR_SWS;

							switch (tmp)
							{
								case 0x00:  /* HSI used as system clock source */
									SystemCoreClock = HSI_VALUE;
									break;
									
								case 0x04:  /* HSE used as system clock source */
									SystemCoreClock = HSE_VALUE;
									break;
									
								case 0x08:  /* PLL P used as system clock source */
			
									pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
									pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
									
									
								/*————————————————差异性代码———————————————— */
								//定义了STM32F40_41xxx或者STM32F427_437xx或者STM32F429_439xx等宏时，代码有效
								
						#if defined(STM32F40_41xxx) || defined(STM32F427souceinsight_437xx) || defined(STM32F429_439xx) || \
								defined(STM32F401xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || \
								defined(STM32F446xx) || defined(STM32F469_479xx)
									if (pllsource != 0)
									{
										/* HSE used as PLL clock source */
										pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
									}
									else
									{
										/* HSI used as PLL clock source */
										pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
									}
									
									//否则如果定义了STM32F410xx或者STM32F411xE宏的话，以下代码有效
						#elif defined(STM32F410xx) || defined(STM32F411xE)
					
									if (pllsource != 0)
									{
										/* HSE used as PLL clock source */
										pllvco = (HSE_BYPASS_INPUT_FREQUENCY / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
									}  
									
								//同理
						#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F412xG || STM32F413_423xx ||  STM32F446xx || STM32F469_479xx */  
									
									
									pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
									SystemCoreClock = pllvco/pllp;      
									break;
								

								
								//同理
						#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)      
									case 0x0C:  /* PLL R used as system clock source */
					  
									pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
									pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
									if (pllsource != 0)
									{
										/* HSE used as PLL clock source */
										pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
									}
									else
									{
										/* HSI used as PLL clock source */
										pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
									}
						 
									pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >>28) + 1 ) *2;
									SystemCoreClock = pllvco/pllr;      
									break;
						#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
						
						
								default:
									SystemCoreClock = HSI_VALUE;
									break;
							}

						}
						
							在IDE中查看源码你会发现，如果条件编译成立的话，所包含的代码就是正常颜色，条件编译不成立，代码的颜
						色为灰色，我们阅读源码时，凡是灰色的代码统统忽略，因为这些不是我们当前需要关心的代码。
						
							很多同学阅读带有条件编译源码时，往往不懂得阅读技巧，很喜欢全部通读，最后越看越糊涂，
						什么原因呢？
						
						（1）差异定代码本来就是只能有一段代码有效，至于哪一段有效则由条件编译来选择，但是你在看的时候
								如果把所有差异代码联合在一起看，代码逻辑自然就是混乱的，肯定是越看越糊涂。
						
						
						（2）没被条件编译选中的代码，与我们关心的平台(os/芯片)并不相干，而是其它平台的，对于其它平台我们并
								不是很熟悉，所以强行阅读不熟悉平台的代码，肯定非常痛苦。
						
						
							所以大家看有条件编译的代码时，一定摸清门道，不然就会越看越糊涂。
							
							
							为了更好的阅读含有大量条件编译的代码，建议使用专门的IDE或者想souceinsight这种源码阅读器来阅读，
						因为它们会自动区分颜色，方便阅读。
							演示：
							
							使用txt文本来阅读时是不颜色区分的，这时我们自己就需要清楚，哪些条件编译成立，哪些不成立，从而区
						分出哪些是我应该关心的代码，不过不建议使用txt文本的方式来阅读，实在是太不人性化。

							有关条件编译这个玩意，还真不是一两句话就能完全讲清楚的，更多的只能等大家工作时，自己去慢慢去体会。
						
							

			
								
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			

		（3）条件编译用途3————调试程序
		
					条件编译在调试中的作用：
				· 注销代码
				· 开、关调试宏
				
				
				1）注销代码
					（a）使用// /* */来注销代码
								使用//、/* */注释代码时，说白了就是告诉“预编译器”把这些代码当做注释来处理。
						
							· 单行注销：使用//来注释
							· 多行注销（代码块注销）：使用/*  */
										使用/* */对代码块注释，其实并不是很方便，因为当你打开代码块时需要将/* */都删掉。
									特别是当/* */注销的代码特别长时，会很不方便。
								
							
					（b）使用条件编译来注销代码
							· 单句代码的注销还是使用//来注销，因为单句使用//更方便				
					
							· 代码块的注销，使用条件编译更方便
								例子：
	
								#if 0    //0就是注销（去掉）代码，1就保留代码
								
								int fun(int va)
								{
									int a = 100;
									
									return a*va;
								}
								
								#endif
		
								int main(void)
								{
									int ret = 0;
									
									#if 0
									ret = fun(1000);
									
									printf("ret = %d\n", ret);
									#endif 
									
									retutn 0;
								}
		
								
				2）开、关调试宏								
						有关调试宏我们在前面就讲过，这里我们使用条件编译来快速的打开和关闭调试宏。
						
						直接代码演示
						#include <stdio.h>
						 
						#ifdef DEBUG1
						# define DBG1 printf("%s %d %s\n", __FILE__, __LINE__, __func__);  
						#else
						# define DBG1
						#endif


						#ifdef DEBUG2
						# define DBG2(info1, info2) printf(info1, info2);                                               
						#else
						# define DBG2(info1, info2)
						#endif
							
						void exchange(int *p1, int *p2)
						{      
							DBG1
							int tmp = 0;
							DBG1
							
							tmp = *p1;
							DBG1
							*p1 = *p2;
							DBG1
							*p2 = tmp;
							DBG1
						}
																		
						int main(void)
						{       
							int a = 10; 
							int b = 30; 
							
							DBG2("%s\n", "1111");
							
							DBG1							
							exchange(&a, &b);
							DBG1
							
							printf("a=%d, b=%d\n", a, b);
						
							DBG1
						
							return 0;
						}
	
						通过条件编译可以将调试宏快速可打开和关闭，方便快速查看调试结果，等调试完毕后，我们再将
					程序中的调试宏删掉。
	
	
	
	
	3.7 条件编译 与 配置文件
			有关配置文件我们在第一章其实就介绍过，我们这里再来详细的说说配置文件。
				
		3.7.1 为什么需要配置文件
				当一个c/c++程序非常庞大时，程序中往往会有很多的条件编译，如果全都自己在源码中一个一个的修改相
			关宏来打开和关闭条件编译的话，这会非常的麻烦，此时就需要用到配置文件来帮我们自动修改相应的宏，
			以打开和关闭相应的条件编译。
				
				
		3.7.2 使用配置文件来打开、关闭条件编译的原理
			配置文件其实一个脚本文件。
			
			（1）修改配置文件：通过配置文件来决定，我想定义哪些宏，想删除哪些宏
			
			（2）执行配置文件：生成config.h，配置文件会往config.h中输入各种条件编译需要的宏定义
			
			（3）编译程序：在源码所有.c/.h中包含config.h，预编译时就可以通过config.h中的宏来打开和关闭
					条件编译了。
						
						
					
		3.7.3 是不是只要程序中有条件编译，就用需要用到配置文件？
			当然不是，
			
			（1）什么情况下，我们没必要使用配置文件
					1）如果你的条件编译是用来注释代码，以及调试程序用的，这些条件编译完全由我们自己手动定义宏
						来打开和关闭

					2）如果代码很简单，全都是通用代码，根本没有用到任何的条件编译，此时根本不需要配置文件
			
					3）你的C虽然用到条件编译了，但是用的非常少，这样的话我们完全可以自己在源码中手动
						修改各种宏定义来打开和关闭条件编译，也不需要配置文件。
						
						总之在我们平时的开发中，对于我们自己写的c程序来说，几乎用不到配置文件。
				
				
			（2）我们什么时候会用到配置文件呢？
			
					1）如果你或者你的团队编写的C工程项目非常复杂，里面涉及大量的条件编译，此时就需要用到配置文件。
							不过这种情况很少见，真的遇到时，那就需要我们自己写配置文件了。
			
					2）下载移植官方c/c++源码时，源码一定会提供配置文件
							比如我们后面移植uboot和Linux内核，uboot和Linux内核的代码不可能我们自己写，所以必须到官网去
						下载官方提供源码，然后修改源码并编译它。
						
							但是官方c源码非常复杂，为了实现跨平台，里面有大量的条件编译，我们不可能读懂所有源码，
						然后直接在源码中去修改宏，然后打开和关闭相应的条件编译，对于像Linux内核这种非常庞大的C
						源码来说，根本不可能。
							
							所以官方一定会提供配置文件给我们，我们直接修改配置文件即可，不需要阅读源码，就算阅读
						源码，也只需要阅读关键部分的源码即可。
							
							
							对于复杂的Linux内核来说，官方还提供了更加人性化的配置文件修改方式。
								那就是我们可以通过图形化的界面去修改配置文件。
			
								演示：	
							
							
								不过对于大多数的配置文件来说，我们都是直接打开文件，然后直接修改。
	
	
								所以其实在实际开发中，我们更多的是去阅读和修改已有的配置文件，而不是制作配置文件。
							
							
		


								
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
		
		3.7.4 我们自己实现一个简单的配置文件
			（1）C程序
					还是之前的例子。
					
					#include "config.h" //我们需要使用“配置文件”来生成config.h

					#ifdef WINDOWS
					# include <windows.h>
					#elif defined LINUX
					# include <sys/types.h>
					# include <sys/stat.h>
					# include <unistd.h>
					# include <fcntl.h>
					#endif
	
					int main(void)
					{
							/* 通用代码 */
							int i = 0;

							while(1)
							{
									if(i>100) break;
									else i++;
							}


					#ifdef WINDOWS
							/* 平台相关代码：windows的操作文件的OS API */
							HANDLE hfile = CreateFileA(".\file", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE \
									| FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
							int dwRead = 0;
							WrieFile(hfile, &i, sizeof(i), &dwRead, 0);   //将i写到file中

					#elif defined LINUX
							/* 平台相关代码：Linux的操作文件的OS API */
							int fd = open("./file", O_RDWR | O_CREAT, 0774);
							write(fd, &i, sizeof(i));  //将i写到file中

					#endif

							return 0;
					}
						

						
						
			（2）实现一个简单的配置文件，然后通过配置文件自动生成config.h
			
						实现配置文件的方式有很多，不管是哪种做法，最终的目的都是为了生成一个config.h，并在config.h
					中定义相关的宏定义，以打开和关闭相应的条件编译。
								
					配置文件有如下两种实现方式：
					
					1）使用makefile文件来实现
							在我们的这里的例子中，就是使用makefile来实现的，makefile就是一个配置文件。
							
							后面讲Uboot的移植时，uboot的配置文件其实也是一个makefile。
							
							
						（a）makefile文件到底是个啥？
									makefile文件主要作用是用于管理C工程项目中的所有.c和.h，以便让编译器更好的去编译所
								有的文件。
								
									不过我们还可以让makefile附带的生成config.h头文件，也就是说生成config.h并不是makefile
								的主要作用。
								
									
						（b）如何得到makefile这个文件？
								（a）自己手动写
								（b）使用工具软件自动生成
								
									我们这里举的makefile的例子是自己写的，但是实际开发中，大型c工程项目的makefile都是
								自动生成的。
								
								
						（c）如何通过makefile文件得到config.h
									后面再演示。
								
									
					2）使用configure.in来实现
							configure.in是一个典型的配置文件，同样的，这个配置文件的作用有很多，生成config.h只是
						其中的一个附带功能而已。
						
							由于configure.in这种方式比较复杂，所以我们这里只简单提一下，后面的课程具体涉及到时，再来
						详细介绍这个文件。
							
						（a）如何得到configure.in？
								· 自己手动写
								· 使用autotools工具链(包含好多工具)，自动生成configure.in
								
									对大型c工程来说，需要的configure.in会很复杂，自己手动写的话非常麻烦，所以都是使用autotools来
								自动生成的，不过由于我们几乎不需要自己制作配置文件，所以我们不需要掌握autotools的使用，
								我们只要能够修改别人制作好的configure.in就可以了。
								
								
						（b）autotools自动生成configure.in的原理？
								autotools工具会去自动扫描源码中所有的.c和.h，根据.c/.h中的条件编译情况，然后自动生成
							configure.in文件。
							
						
						（c）如何利用configure.in得到config.h
								有了configure.in这个配置文件后，在命令行执行./configure命令，该命令就回去处理
							configure.in文件，然后得到config.h。
							
								前面说过，configure.in的作用很多，生成config.h只是其中的一个作用。
								有关configure.in更多的内容，我们后面课程用到时再来具体介绍。

								
								
								
				（3）使用makefile生成config.h
						1）写一个makefile文件
								
							Makefile：
								all:
												gcc -o helloworld helloworld.c

								configure:
												#执行脚本文件config,config会创建congfig.h
												#如果传给脚本的参数是win,就往config.h中写入#define WINDOWS
												#如果传给脚本的参数是Linux,就往config.h中写入#define LINUX
												./config win 
												#./config linux


								clean:
												#执行脚本文件config,传入参数为clean
												#脚本文件会删除可执行文件helloworld和config.h
												 ./config clean 
							
								
								使用make命令来执行Makefile文件。
							
							（a）make all -f Makefile：编译helloworld.c，-f Makefile可以省略
							（b）make Win：执行config脚本文件，创建config.h，然后在里面定义WINDOWS宏
							（c）make Linux：执行config脚本文件，创建config.h，然后在里面定义LINUX宏
								
							
							
						2）编写脚本文件config
							
							config：
								#!/bin/sh -e

								#如果config.h文件之前就存在,就使用原来的文件
								touch config.h

								#清空文件内容
								:>config.h


								#将pragma once输入config.h,防止头文件重复包含
								# >: 会覆盖以前的内容
								echo "#pragma once" > config.h


								#如果脚本文件参数为win,将#define WINDOWS追加到configh中,>>为追加
								if [ "$1" = "win" ] ; then

								echo "#define WINDOWS" >> config.h

								fi

								#如果脚本文件参数为linux,将#define LINUX追加config.h
								if [ "$1" = "linux" ] ; then

								echo "#define LINUX" >> config.h

								fi

																
							makefile会执行这个脚本文件，通过给脚本文件传递不同的参数，就可以让脚本做不同的事情。
								
							疑问：我不会makefile和脚本怎么办？
							（a）在《c深度解析》第9章，我们会专门的介绍makefile，我们这里介绍makefile其实非常简单。
							（b）至于脚本，后面会有单独的课程来介绍。						
														

			
		3.7.6 我们如何对待配置文件
				不管是makefile这种配置文件，还是configure.in这种配置文件，我们应该怎么正确的对待配置文件呢？
				
				
			（1）我们需要自己制作配置文件吗
						对于我们一般的C应用开发来说，写的C工程都不是很复杂，而且程序中基本都是通用代码，用不到条
					件编译，所以我们自己不需要制作配置文件。
						
						除非你自己写的C工程非常复杂，有大量的条件编译，而且别人还需要下载你的源码然后去移植，此时
					你就必须提供配置文件，如果你不提供配置文件的话，别人几乎不可能去阅读你的源码，在源码中修改
					宏定义，以打开和关闭相应的条件编译。
						
						其实制作配置文件并不难，网上也有相应的教程，不过我觉得没有必要自己制作，因为确实没有这种
					需求，如果真的遇到这种需求了，参照网络教程，你自己也可以制作配置文件。
					
						
						对于Linux嵌入式开发来说，我们往往会下载、移植官方源码，为了方便我们操作，官方源码一定会提
					供配置文件给我们，所以在Linux嵌入式开发里面，我们更多的是阅读和修改别人所提供的配置文件，
					而不是自己制作配置文件。
		
						
			（2）如何才能看懂配置文件
					大家只需要跟着课程走，当后面课程涉及到配置文件时，你看我们是怎么阅读和修改配置文件的，你把我
				们所讲解的内容搞定了，其实配置文件也就基本搞懂了。
				
					一定要记住我们是搞开发的，不是搞研究的，不要去专门的深入的研究配置文件，这样做对于开发
				来说价值不大。而且配置文件的原理也不难，也没有什么好深入研究的，就算你深入研究了，也不会对我
				们的实际开发带来更多收益，所以对于配置文件，大家就跟着我们的课程走就可以了。
					
					
					修改配置文件时，如果你想把整个配置完全看明白的话，这是其实不可能的，因为大型c工
				程的配置文件会非常长，根本不可能全部看完而且还全部看明白。
					
					对于我们来说，我们只要能把配置文件中的关键点看懂并修改正确，保证整个源码能够被正常编译通过，
				这就足够了，不过要做到这一点的话也不容易，因为你不知道应该看哪一点，修改哪一点，所以很依赖于
				经验，我们后面的课程就会介绍这样的经验。

				
				
		3.7.7 总结一下，如何打开和关闭条件编译
			
				打开、关闭条件编译，是靠定义和删除宏来实现的，所以打开和关闭条件编译，最终就演变为了“定义和删除宏”。
				
				有三种方式：
				
				
		（1）通过修改配置文件，从而决定定义哪些宏、删除哪些宏
					
					不过一般只有大型工程才会使用配置文件这种方式，而且大型工程一般也不是我们自己写的，而是从官方下载
				的像Linux/安卓等的这种源码。
					
					疑问：为什么大型工程才需要使用配置文件呢？
					答：因为大型工程很复杂，要修改的内容太多了，只有配置文件这种方式是最合适的。
				
				
		（2）直接修改.h/.c，在里面直接定义或者删除宏
					这种方式最直接、最简单明了，不过工程变复杂之后，这种方式就不是很方便了，所以这种方式一般都只应用于我们
				自己写的小型工程上。
		
		
		（3）还有一种方式，那就是通过IDE设置来定义和删除宏
					前面没有介绍这种方式，这里需要补充一下。

					直接修改.h/.c有一个缺点，那就是修改代码时手一抖，不小心把代码改错了，结果就把自己给坑了。
		
					通过IDE设置来定义和删除宏的好处就是，可以不用修改代码。
					
					演示：
					
					
					
					通过IDE设置所定义的宏，对整个工程中所有的文件都是可见的。
					通过定义这些宏，就可以对库中代码进行选择，只保留某系列芯片才需要的代码。
					
					
					像这这种方式，一般常见于单片机开发中，不针对自己的应用代码，主要是针对官方提供的库、框架。
				我们演示的例子，就是STM32标准库的例子。
				
				
				疑问：为什么单片机的库、框架常使用这种方式？
				答：因为单片机的库、框架源码一般比较简单，不需要那么多的配置，如果非给弄一个配置文件的话，反倒还把事
				搞复杂了，但是如果直接修改源码的话，很多人对源码又不是很熟悉，非常容易改错地方，所以人家才提供了这
				种这种方式，这种方式既简单，同时又规避了错改源码的风险。
					
					
					
					
				
				
				
				
		
		
			
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
			
4. 其它的一些“预处理”关键字		

	4.1 有哪些关键字
		#error 
		
		defined 
		
		#line

		#和## 
		
		#pragma
		
		
	4.2 #error
			不过我们先不忙着介绍#error，先讲讲如果宏定义不存在的话，如何报宏定义不存在的错误。
	
	
		4.2.1 如果引用某个宏时，该宏没有被定义的话，怎么报错
			（1）例子
					a.c 
					#include <stdio.h>
					
					int main(void)
					{
						
						printf("%f\n", PI);
						
						return 0;
					}
					
						由于PI这个宏没有定义，因此预编译阶段处理时，没办法对PI进行替换，所以PI这个符号会一直留到编译阶段，
					第二阶段编译时就会报PI不存在的错误。
					
						也就是说，引用的宏没有定义时，正常情况下是由第二阶段编译来报的错误。
				
					但是由“编译阶段”来报宏的错误存在如下缺点：
					
					1）编译器无法精准报错
							它只会提示缺少符号PI，但是并不能提示缺少的PI是一个宏，因为编译器只知道PI这个符号没有定义，但是并
						不知道PI其实是一个宏，所以我们自己排错时，需要我们自己区分PI是个函数、变量、还是宏。
						
							总之，报错时如果能够告诉你符号PI是个宏的话，可以帮助我们快速排查PI这个宏相关的错误。
							
							
							疑问：我自己写的代码，我自己难道还不知道PI是个啥吗？
							答：问题是
							（a）很多复杂的源码并不是自己写的，而是你到网上下载别人的源码，如果只是提示缺符号PI，你并不知道
								PI到底是个啥，不利于精确排错。
						
							（b）就算是你自己的写c工程，当工程写复杂后，定义的符号必然非常多，冷不丁的提示缺符号PI，其实你也
									很难一下反应过来PI是一个宏。
						
							
					2）当源码很庞大时，编译时报错会非常迟缓
							对于庞大的项目源码来说，往往可能有成百上千个.c文件，编译时间动辄就会花上30分~十几小时，某个引用“未
						定义宏”的.c，可能要等30分钟后才编译到它，然后再报符号未定义的错误，此时这个报错就太迟缓了。
							
							对于编译的四个过程来说，第二个阶段“编译”所花费的时间最久，预编译的时间最短，所以如果在
						“预编译阶段”就报宏的错误，而且准确提示未定义的符号是一个宏的话，宏的排错效率非常高。
					
							而且宏本来就是在“预编译阶段”处理的，所以在“预编译”阶段报宏的错误，也是最贴切的。
											
							所以综合起来就是，宏没有定义的错误就应该在“预编译”阶段进行报告，而不是留到编译阶段。
							当然那些只能编译阶段报的错误，你就不能到预编译阶段报错了，比如某个变量、函数没有定义，像这种的
						就只能在编译阶段报错了。
					
						
						
			（2）准确报“宏不存在的错误”有什么意义？
						
						你现在可能觉得没有什么意义，那是因为你的级别还不够，你还局限于你自己写的小程序，对于小的C程
					序来说，你自己仔细挨个检查文件就能搞清楚未定义的符号是个宏，还是个啥。
						
						但是我们在实际开发中（比如嵌入式开发），往往需要下载官方大型的C源码（比如uboot，Linux OS）来进行
					移植，在移植中修改源码时，宏的修改会比较多的，因为条件编译需要这些宏来打开和关闭，所以在预编译
					阶段如果就能准确的提示缺少某个宏的话，可以帮助我们快速排查宏的错误。
						
						
						
						对于下载的官方源码来说往往很复杂，如果不能准确提示缺少的符号是个宏，而需要你自己去阅读源码来确定
					这个符号是个宏，然后解决宏的错误，这无疑就太痛苦了。
			
						#error这个玩意就能够帮助我们在“预编译”阶段，及时准确的报宏相关的错误。
			
			
		4.2.2 正式说说#error		
		
			（1）作用
					在“预编译阶段”打印提示相关信息。
					可以打印任何你要的信息，具体什么信息，可以由你自己定义。
					
					例子：
					a.c 
					#include <stdio.h>
					
					#error helloworld  //注意helloworld不需要""
					
					int main(void)
					{
					
						return 0;
					}
					
					
					其实“干用#error”的意义并不大，前面就说过，#error常用于提示宏相关的错误，比如举一个简单的例子：
					#include <stdio.h>
					

					
					int main(void)
					{
						
					#ifdef PI 
						printf("%d\n", PI); 
						
					#else 
					# error PI not defined 
						
					#endif	
						
						retutn 0;
					}
					
			
			（2）#error的特点总结
					1）#error是在“预编译阶段”由预编译器处理的“预编译关键字”
					
					2）执行#error后，“预编译”的处理过程会被立即终止
							
						
					3）#error输出字符串时，信息内容不需要使用""括起来
							#error helloworld
							
			
			（3）#error提示宏不存在时怎么办
			
					1）如果该宏定义在了某个.h中
							我们只需要将该.h包含到.c中，该宏就有了。
							
							疑问：我怎么知道这个宏在哪个头文件呢？
								如果是常用宏，一般我们自己都知道这个宏定义在了哪个.h中，比如stdin这个宏就定义在了stdio.h中。
							但是在移植官方源码时，源码会非常复杂，涉及到的.h会非常多，很难搞清楚在哪个.h中，不过源码除了会使用
							#error报某个宏未定义外，还会精确的提示你这个宏在哪个.h，你应该包含这个.h。

							举一个简单例子演示下。
							
							#ifndef stdin
							#error macro stdin not defined, please include stdio.h
							
							#endif
							
							int main(void)
							{
								fprintf(stdin, "hello world\n"); //等价于printf("hello world\n");
								
								return 0;
							}
							
								这个例子很傻瓜，没有太大的现实意义，但是在复杂的C工程源码中，这种类似的做法确实非常常见的。
							
								很多同学在编译某些源码时，经常看到“你需要包含什么头文件”的提示，就是使用#error在预编译阶段提示的。
								
								
							
					2）如果宏没有定义在某个头文件中呢，怎么办呢
							此时可能就需要我们在某个.h或者.c亲自去定义了。
					
						1）例子1
								#include <stdio.h>
				
								int main(void)
								{
									
								#ifdef PI 
									printf("%d\n", PI); 
									
								#else 
									#error PI not defined 
									
								#endif	
									
									retutn 0;
								}
							
									直接在.c头上、或者在自己的某个.h中，自定义PI（#define PI 3.1415）。
								
									对于自己写的简单c程序来说，一般都是这么办的就这么办。
									
									
							2）例子2
									对于从官方下载的复杂c源码来说，好些宏是与条件编译相关，由于源码太过复杂，而且又不是你自己写的，
								如果你想通过阅读源码，然后再源码中去定义缺失的宏，这种方式几乎是不可能实现的。
								
									所以在复杂的C源码中，如果是与条件编译相关的宏，我们需要去修改配置文件，已得到相应的宏。
								
									
		
		
			
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
		
		
	4.2 defined 
			我们在介绍#if时就介绍过defined的使用，它常与#if、!配合使用。
			
			#if defined MACRO1 && !defined MACRO2
			...
			
			#endif
			
			由于前面介绍过，所以我们这里就不在赘述。
			
			
	4.3 #line
		4.3.1 作用
			可以根据你自己的需求，修改__LINE__和__FILE__的值，也就是修改行号和文件名。
			
			修改的值永久生效。
			
			
		4.3.2 举例理解：
			a.c 
			#include <stdio.h>
			
			int main(void)
			{
			#line 1 "b.c"
				printf("%d %s\n", __LINE__, __FILE__);
				
				
				return 0;
			}
			
			查看预编译结果：
			int main(void)
			{
				#line 1 b.c
				printf("%d %s\n", 1, "a.c");
				
				return 0;
			}
		
		4.3.3 使用#line修改行号和文件名有什么意义
				实际上对于我们自己写C/c++程序而言，几乎用不到#line这个东西，只有我们在看某些源码时才会见到它。
				
				至于使用#line修改行号和文件名，到底有什么意义，这个问题我们这里不介绍，因为一两句话说不清楚，我们只
			要知道#line的作用是修改行号和文件名就行。
			
			
			
	4.4 #和##		
			很多学习c语言的同学很容易忽略这两个东西，但是在源码中，这两个玩意经常出现。	
			大家在理解了#和##的用法后，也希望大家在自己的C程序中使用，以提高自己代码质量。
				
				
		4.4.1 #
		（1）作用：将宏参数变为字符串。
					这里讲的#与#define、#include中的#的作用是不同的，不要搞混了。
					
					
		（2）例子
				1）例子1
						#include <stdio.h>
							
						#define STR(s) #s
							
						int main(void)
						{	
							printf("%s\n", STR(hello world));
							
							return 0;
						}	
						
						STR(hello world)的替换过程：
						STR(hello world) ————————>#hello wolrd ——————> "hello world"
						
						
						查看预编译后的结果：
						...
						...
						# 5 "helloworld.c"
						int main(void)
						{
						 printf("%s\n", "hello world");

						 return 0;
						}
						
						疑问：# 5 "helloworld.c"是什么意思？
						表示.i中该部分的内容，来至于那个文件。

		
				2）例子2
					#include <stdio.h>
					
					#define STR1(s) #s" wolrd"
					#define STR2(s) "hello "#s

					int main(void)
					{
						printf("%s\n", STR1(hello));
						printf("%s\n", STR2(world));
										
						return 0;
					}    
					
					查看预编译后的结果：
					int main(void)
					{
						printf("%s\n", "hello"" wolrd"); 
						printf("%s\n", "hello ""world");

						return 0;
					}
					
					疑问： "hello"" wolrd"这种写法可以吗？
					答：可以，与"hello world"是等价的。

					STR1(hello)   #hello" wolrd"  "hello"" wolrd"  
					
		4.4.2 ##		
		（1）作用：将两个标识符连接在一起，合成一个标识符
		（2）例子
				#include <stdio.h>
					
				#define ADDR1 0x12343654
				#define ADDR2 0x54543243
				
				#define MACRO(a, b) a##b	
				
				int main(void)
				{	
					int *p = MACRO(ADDR, 1);
					
					return 0;
				}	
				
				MACRO(ADDR, 1)处理的过程：
				MACRO(ADDR, 1) ——————> ADDR##1 ———————> ADDR1 ————————>0x12343654
				
				
				查看预编译后的结果：
				int main(void)
				{
				 int *p = 0x12343654;

				 return 0;
				}

				
				
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
						
				
		4.4.3 #和##到底有什么实际意义 —————— 看看#和##的真实案例
				我从Linux内核中抽取了一个真实的案例，在这个案例中#和##都用到了，通过这个例子看看#和##到底有什么使
			用价值。
			
			（1）没有#和##时的正常做法
					#define QDSP_MODULE_AUDPPTASK 	1
					#define QDSP_MODULE_AUDRECTASK		2
					#define QDSP_MODULE_UDPREPROCTASK 	3	
					
					struct adsp_module_info 
					{
						const char *name;
						const char *pdev_name;
						uint32_t id;
					};
					
					struct adsp_module_info module_info[] = 
					{
							{.name="AUDPPTASK", .pdev_name=adsp_AUDPPTASK, .id=QDSP_MODULE_AUDPPTASK},
							{.name="AUDRECTASK", .pdev_name=adsp_AUDRECTASK, .id=QDSP_MODULE_AUDRECTASK},
							{.name="UDPREPROCTASK", .pdev_name=adsp_UDPREPROCTASK, .id=QDSP_MODULE_UDPREPROCTASK}
					};
						
					从这个例子中可以看出，给结构体数组初始化的值的名字很有规律，比如。
										 "AUDPPTASK"
								 adsp_AUDPPTASK
					QDSP_MODULE_AUDPPTASK_1
		
					基于这个规律完全可以使用#和##处理，在Linux内核中确实也是这么做的。

					
			（2）使用#和##处理后
					#define QDSP_MODULE_AUDPPTASK_1 	1
					#define QDSP_MODULE_AUDRECTASK_2	2
					#define QDSP_MODULE_AUDRECTASK_3 	3	
					
					#define QDSP_MODULE(n) { .name = #n, .pdev_name = "adsp_" #n, .id = QDSP_MODULE_##n }
					
					struct adsp_module_info {
						const char *name;
						const char *pdev_name;
						uint32_t id;
					};
					
					struct adsp_module_info module_info[] = 
					{
							QDSP_MODULE(AUDPPTASK),
							QDSP_MODULE(AUDRECTASK),
							QDSP_MODULE(UDPREPROCTASK)
					};		
										
						使用#和##修改后，其实代码的执行效率并没有发生变化，但是使用了#和##后，确使得源码更加的简洁，
					在Linux内核、框架的C/C++源码中，大量充斥着这种用法，希望通过这里的介绍后，大家不再陌生这样的用法。	
					
					
					预编译时处理的过程：
					QDSP_MODULE(AUDPPTASK) 
										|
										V				
					{ .name = #AUDPPTASK, .pdev_name = "adsp_" #AUDPPTASK, .id = QDSP_MODULE_##AUDPPTASK }
										|
										V
					{ .name = "AUDPPTASK", .pdev_name = "adsp_" "AUDPPTASK", .id = QDSP_MODULE_AUDPPTASK }					
					
					
					QDSP_MODULE(AUDRECTASK)和QDSP_MODULE(UDPREPROCTASK)处理也是一样的过程。
					
					
					
					查看预编译后的结果：
					struct adsp_module_info {
						const char *name;
						const char *pdev_name;
						uint32_t id;
					};

					struct adsp_module_info module_info[] =
					{
						{ .name = "AUDPPTASK", .pdev_name = "adsp_""AUDPPTASK", .id = QDSP_MODULE_AUDPPTASK },
						{ .name = "AUDRECTASK", .pdev_name = "adsp_""AUDRECTASK", .id = QDSP_MODULE_AUDRECTASK },
						{ .name = "AUDRECTASK", .pdev_name = "adsp_""AUDRECTASK", .id = QDSP_MODULE_AUDRECTASK }
					};
					
					
		4.4.3 #和##的一些需要注意的地方
		
			（1）直接使用#和##行不行
						#include <stdio.h>
						
						int main(void)
						{
							int helloworld = 100;
						
							printf("%s\n", #hello);
							printf("%d\n", hello##world);
									
							return 0;
						}
						
						查看预编译结果：
						
						# 4 "helloworld.c"
						int main(void)
						{
							int helloworld = 100;
						
							printf("%s\n", #hello);
							printf("%d\n", hello##world);

							return 0;
						}
						
							从预编译的结果#hello、hello##world可以看出，#和##没有起到任何的作用。
						
						从这里的例子可以看出，#和##只能和宏一起结合使用时，才能起到作用。
						
						#include <stdio.h>
						
						#define MACR1(s) #s
						#define MACR2(a, b)  a##b
						
						int main(void)
						{
							int helloworld = 100;
							
							printf("%s\n", MACR1(hello));
							printf("%d\n", MACR2(hello, wolrd));
									
							return 0;
						}
				
			（2）无参宏行不行
					#include <stdio.h>

					#define MACRO1 #helloworld
					#define MACRO2 hello##world
					
					int main(void)
					{
						MACRO1;
						MACRO2;
						
						return 0;
					}
					
					查看预处理后的结果：
					...
					...
					# 8 "helloworld.c"
					int main(void)
					{
						#helloworld; //失败了
						helloworld;  //成功了

						return 0;
					}
											 
					从这个例子可以看不出，#只对宏参数有效，但是##就不是，对于##来说，以下写法都是OK的。
					#define MACRO(a, b) a##b
					#define MACRO(a, b) a##b##_tag
					#define MACRO info##_tag
						
										
										
										
										
		（3）使用#和##时，如果宏的参数也是一个宏的话，会怎样
		
				1）在没有#和##的情况下，如果宏的参数是另一个宏的话，会怎样
						#include <stdio.h>
						
						#define PI 3.14
						#define AREA(r, p) (r)*(r)*(p)


						int main(void)
						{
										printf("%s\n", AREA(2,PI));

										return 0;
						}
						
						
						查看预编译结果：
						...
						...
						# 8 "helloworld.c"
						int main(void)
						{
							printf("%d\n", (2)*(2)*(3.14));

							return 0;
						}
											 
						在没有#和##的情况下，参数是宏时，“参数宏”也可以正常展开。			
						
						
				2）当有#和##时，如果宏参数是另一个宏的话，会怎样
					（a）#的例子
					
						#include <stdio.h>

						#define NUM 100
						#define STR(num) #num

						int main(void)
						{
										printf("%s\n", STR(NUM));

										return 0;
						}
						
						查看预编译结果：
						int main(void)
						{
							printf("%s\n", "NUM");  //参数宏NUM没有被展开，或者说替换为100
							return 0;
						}
						
						展开的过程：
						STR(NUM) ———> #NUM ————> "NUM" 
						
						为什么没有展开？
							因为#是直接将NUM作为一个符号给处理了，你给它什么它就处理什么，它直接将得到玩意变为字符串，
						它并不会理会它是不是一个宏，是的话然后去展开它。
						
						如果NUM想要展开的话，怎么办？
						再加一层宏定义，先展开参数宏NUM，再展开有#的宏。
						改进如下：
						#include <stdio.h>

						#define NUM 100
						#define STR(num) #num
						#define _STR(num) STR(num)

						int main(void)
						{
										printf("%s\n", _STR(NUM));

										return 0;
						}
						
						展开的过程：
						 _STR(NUM) ——> STR(NUM) ——>STR(100) ——> #100 ———>"100" 
						
						查看预编译结果：
						int main(void)
						{
							printf("%s\n", "100"); //展开成功
							
							return 0;
						}
						
						NUM展开后，#处理的符号就是100，所以就得到了字符串100。
						
						
						
				（b）##的例子
						#include <stdio.h>

						#define TAG1 info
						#define TAG2 _teacher

						#define STRUCT(a, b) struct a##b

						STRUCT(TAG1, TAG2)
						{
								int num;
						}

						int main(void)
						{

							return 0;
						}
						
						查看预编译后的结果：
						struct TAG1TAG2
						{
							int num;
						}

						int main(void)
						{

							return 0;
						}
						
						
						展开的过程：
						STRUCT(TAG1, TAG2)  struct TAG1##TAG2   struct TAG1TAG2 



						——> struct TAG1##TAG2 ——> struct TAG1TAG2
						
						
						为什么TAG1和TAG2没有展开？
						原因与#一样，你给##什么符号，它就将什么符号连接起来，它不会去识别这个符号是个宏并展开它。
						
						如果想将TAG1和TAG2展开怎么办？
						同样的，在中间再加一层宏定义，将参数宏TAG1和TAG2展开后，在使用##连接起来。
						
						#include <stdio.h>

						#define TAG1 info
						#define TAG2 _teacher

						#define STRUCT(a, b) struct a##b
						#define _STRUCT(a, b) STRUCT(a, b) //加的一层

						_STRUCT(TAG1, TAG2)
						{
							int num;
						}

						int main(void)
						{

							return 0;
						}
						
						查看预编译后的结果：
						struct info_teacher
						{	
							int num;
						}	
							
						int main(void)
						{	
							
							return 0;
						}	
						
						展开的过程：
						_STRUCT(TAG1, TAG2) ——>STRUCT(TAG1, TAG2) ——> STRUCT(info, _teacher) ——>
						——>struct info##_teacher ——> struct info_teacher
						
						加一层宏的原理就是：
							先将TAG1和TAG2展开为info, _teacher，然后再交给##，由##将info, _teacher连接在一起。
			
			
		4.4.4 在看一些#和##的使用例子	
				#相比##来说，用的不如##多，所以我们这里就不在举#的例子了，我们这里重点再举一些##的例子。
					
			（1）##的例子1
					1）定义结构体的例子
					
						struct info_student 
						{	
							char name[30];
							int num;
						};
						typedef struct info_student student;
						
						
						struct info_teacher
						{	
							char name[30];
							int id;
						};
						typedef info_teacher teacher;
						
						
						struct info_administor
						{	
							char name[30];
							int id;
						};
						typedef struct info_administor administor;
						
							比如像以上的这些例子，当需要定义好多结构体类型，而且这些结构体类型的格式还非常相似时，我们可以使
						用##来简化操作，让代码变的更简洁。
							
							
					2）使用##简化后
						#define STRUCT(type) typedef struct info_##type type; struct info_##type
						
						STRUCT(student)
						{
							char name[30];
							int num;
						};
						
						STRUCT(teacher)
						{	
							char name[30];
							int id;
						};
						
						STRUCT(administor)
						{	
							char name[30];
							int id;
						};
						
						int main(void)
						{
							
							return 0;
						}
						
						查看预处理的结果：
						...
						# 6 "helloworld.c"
						typedef struct info_student student;
						struct info_student
						{
						 char name[30];
						 int num;
						};

						typedef struct info_teacher teacher;
						struct info_teacher
						{
						 char name[30];
						 int id;
						};

						typedef struct info_administor administor;
						struct info_administor
						{
						 char name[30];
						 int id;
						};
						
						int main(void)
						{
							
							return 0;
						}
											
						疑问：typedef进行类型命名的操作，在结构体类型定义的前面可以吗？
						答：完全可以。
				
				
				
				
				
			（2）module_init(mouse_device)

					#define __define_initcall(level,fn,id) \
						static initcall_t __initcall_##fn##id __used \
							__attribute__((__section__(".initcall" level ".init"))) = fn

						module_init宏最终对应的是__define_initcall宏，其中就有使用##，由于之前介绍过，这里就不在
					赘述。
					
					
			（2）##的例子2					
						我们这里举一个win32的C图形界面接口例子。
						
						
						直接分析例子：
						
	
					
		4.4.5 如何分析#和##
				通过前面的例子可知，#和##是不能直接单独使用的，必须和宏结合在一起使用，所以分析#和##的过程，
			其实就是分析一个复杂宏定义的过程。
				
				那么面对#和##的宏定义时，我们应该怎么办呢？
			（1）如果通过宏名称就能明白该宏做了什么事情，此时完全不需要去分析这个宏的宏体
					
			（2）如果不分析该宏就无法理解相关源码的话，那就必须分析该宏定义，如何分析呢？
						我们在前面就讲过，对于复杂宏定义的分析没有捷径可走，只能是一步一步的替换找到本源，只有
					找到本源后，才能知道该宏的真正用意是什么。
				

				
					
				
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
									
					
	4.5 #pragma
		
		4.5.1 #pragma的学习定位
				在所有的预处理关键字中，#pragma的用法应该是最复杂的，然而然并卵，虽然复杂但是在实际开发中用
			的并不多，很多人做了很久的C开发，但是可能都没有听过#pragma。
			
				不过，虽然在我们自己的C应用程序中，#pragma虽然用的不是特别多，但是在源码中还是会看见的，因为
			这个原因，我们这里需要介绍一下#pragma，免得大家看到后不认识。
				
				对于#pragma来说，我们的学习定位就是了解其基本用法，但是不要深钻。
				
				尽管我们的课程叫“c深度解析”，但是我们的课程也不是一味的深入，我们的课程也是有课程定位和课程
			目标的，我们课程的目的是提高c的深度开发能力，如果某个知识学习已经完全越过了这个目标，都到了有点
			钻牛角尖地步时，那么像这类知识点就不再深入，因为我们并不是天天有大把时间搞科研的教授和专家，是以
			实用为主，所以学习时必须注重学习的性价比，如果不实用你还去深钻的话，最终只是在浪费时间。
				
				所以像#pragma这种难度，但是又没有什么大用的知识，我们应该本着务实的态度来学习。
				
				怎么务实呢？
				明白#pragma基本功能即可，如果以后因为某种特殊原因，你用到了#pragma的深入用法时，再根据实际情况
			去有针对性的深入学习即可，这种有针对性的学习，其学习效率更高。
			
			
		4.5.2 #pragma的作用
				通过#pragma指定的某些设置，然后通过这些设置告诉编译器在预编译或者编译时，完成某些特定的事情。
		
		
		4.5.3 #pragma的一个有意思的特点
				#pragma与其它“预编译关键字”的一个比较大的区别是，其它的预编译关键字都是在“预编译”阶段被处理的，
			预编译之后就看不到了，但是#pragma就不一定了，#pragma的大多数用法是在预编译阶段处理的，但是有些少
			数情况是在第二阶段“编译”时处理的。		
	
	
		4.5.3 #pragma的使用格式
			#pragma parameter(参数)
			
			通过指定不同的参数（parameter），告诉编译器在编译时完成某些特定事情。
			
			
			#pragma的参数表：
				*表示仅C++支持，其它的C/C++都支持
				
				alloc_text    comment     init_seg*    optimize         auto_inline       component  
				inline_depth  pack        bss_seg      data_seg         inline_recursion  pointers_to_members*  
				check_stack   function    intrinsic    setlocale        code_seg          hdrstop      
				message       vtordisp*   const_seg    include_alias    once              warning
				
				很多同学看到这个参数表时估计都被吓到了，其实不用害怕，因为这里面的很多参数我们几乎用不到，
			所以这里仅仅只是列举出来让你见见而已，我们只需要通过其中某几个参数来介绍下#pragma的基本使用即可。
				
			
		4.5.4 #pragma的常用参数
		（1）#pragma once
				1）作用
						与#ifndef一样，可以用于防止头文件的重复包含，只不过ifndef方式是最古老、最普遍的方式，
					所有的C/C++编译器都支持，而#pragma once是一个比较新的方式，有些编译器可能并不支持
					#pragma once方式。
						
						不过经过多年的发展，现在大多数编译器都支持#pragma once的这种写法了，比如gcc编译器就支持
					这种写法，所以当你在某些头文件看到了#pragma once的写法时不要蒙圈。
					
						不过目前主流的还是#ifndef方式，不过为了让程序有更好的移植性，我们建议大家还是多使用
					#ifndef的方式，毕竟编译器对这种方式的支持性更好些。
						
						有些头文件可能会比较奇葩，在文件头上，#pragma once和#ifndef方式都有，编译器支持哪种
					它就用哪种。
					
				2）#pragma once使用举例
					helloworld.h
						#pragma once  //预编译后，#pragma once就没有了

						struct stu
						{
							int num;
							char name[20];
						};
					
					
					
					helloworld.c
						#include <stdio.h>
						#include "helloworld.h"
						#include "helloworld.h" //重复include

						int main(void)
						{

							return 0;
						}
				
				
					查看预编译的结果：
					# 3 "helloworld.h"
						struct stu   //struct stu结构体类型的定义只有一个，说明#pragma once成功的防止了头文件内容的重复。
						{ 
						 int num;
						 char name[20];
						};
						# 3 "helloworld.c" 2


						int main(void)
						{


						 fun(10);

						 return 0;
						}
						
					
				3）#pragma once与#ifndef实现方式的区别
						这二者都能实现防止头文件内容重复，只不过在实现原理上有一点区别。
						
					（a）#ifndef
							如果helloworld.h使用#ifndef方式来实现的话，两次include的helloworld.h的内容都
						会被复制到到.c文件中，然后使用#ifndef保留第一次包含内容，然后去掉重复内容。
							
							#ifndef的原理就是，先把所有.h的内容都复制到.c中（包括重复的），然后使用#ifndef来去掉
						重复的内容。
						
					（b）#pragma once
							#pragma once与ifndef有所不同，使用#pragma once方式来实现时，只会复制第一次incldue的.h的
						内容到.c中，后续重复inlcude的.h的内容根本不会被复制到.c中，后续重复的inlcude会被直接被判
						定无效。
					
							从以上介绍可以看出，从效率上来说，#pragma once的效率比#ifndef方式更高，因为使用#ifndef
						方式时，所有重复include的.h的内容都需要被复制到.c中，但是#pragma once不会。
						
						
							
				
		（2）#pragma auto_inline				
				这一个与“内联函数”有关，后面在函数章节讲内联函数时，再来介绍。
				
				
				
		（3）#pragma message(message string)
				1）作用
						在编译时打印提示信息，注意我说的是在编译时而不是在预编译时，也就是说#pragma message这话
					是在第二阶段“编译”时才会起作用的。
				
				
				2）使用举例
					（a）例子1
							hellowolrd.c
								#include <stdio.h>

								#ifndef _ARM

								#pragma message( "macro _ARM not defined" )

								#endif

								int main(void)
								{

												return 0;
								}

	
							查看预编译结果：
								# 7 "helloworld.c"
								#pragma message( "macro _ARM not defined" )
								# 7 "helloworld.c"

								
								# 11 "helloworld.c"
								int main(void)
								{

									return 0;
								}
								
								预编译后，#pragma message( "Pentium processor build" ) 还在，说明还没有被处理。
								
							编译：gcc -S helloworld.i -o hellowolrd.s
							
							输出信息：
								helloworld.c:5:9: note: #pragma message: macro _ARM not defined
								#pragma message( "macro _ARM not defined"
								
								通过以上的这个例子，我们也可以通过#pragma message这种方式，在“编译阶段”提示某个宏有没
							有被定义，不过我们前面也说过，有关宏的报错，应该尽量在预编译阶段使用#error来报错会更好，
							至于为什么建议这样，我们前面有介绍过原因。
								
								
					（b）例子2		
							hellowolrd.c
								#include <stdio.h>

								#pragma message( "Compiling " __FILE__ )  //提示目前正在编译什么文件

								int main(void)
								{
												return 0;
								}

							编译：gcc helloworld.c 
								helloworld.c:3:9: note: #pragma message: Compiling helloworld.c
								#pragma message( "Compiling " __FILE__ )
							
							
								通过#pragma message可以在编译时的打印提示信息，有编译过大型c工程的同学估计都知道，
							在编译的过程中，往往打印很多的编译时的提示信息，告诉你目前编译到什么位置了，目前被编译
							文件是哪一个，编译状态是怎样的，其实这些信息大多都是#pragma message打印出来的。
							
								通过提示的这些信息，可以向编译者提示编译状态，特别编译开源的官方C源码时，打印提示信
							息还是很重要的，因为通过这些提示信息，可以帮助排查错误，实现源码的移植。
								
								你将来写大型C工程项目时，你也可以使用#pragma message来打印编译时提示信息。
								
								
								
			（4）#pragma pack：内存对齐
					后面讲到结构体的内存对齐时，我们再来介绍这个玩意。
							
							
			（5）bss_seg、data_seg、code_seg、const_seg
				
					1）bss_seg：修改和设置.bss节
					2）data_seg：修改和设置.data节
					3）const_seg：修改和设置.ro.data节
					4）code_seg：修改和设置.text节
						
						这些简单了解即可，因为如果要研究清楚的话，其实内容还比较深，但是就算你研究明白了，对于我们
					实际开发的意义并不大，因此这里只简单提下。
					
						有关#pragma其它参数，我们这里也是持同样的观点，以后真的当你遇到某种特殊参数时，你再有针对
					性的去学习，效果会更好。
				


				
				

				
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------			
								
5. 文件包含（#include 文件）

	5.1 #include是不是只能包含头文件？
			很多同学往往有一个误解，认为include只能包含头文件，实际上不是的，include可以包含任何文件，比如包含
		普通的文本文件，其它.c文件，只不过我们很少包含普通的文本文件和.c文件而已。
			
			
		5.1.1 为什么不包含普通文本文件
				因为在普通文本文件里面，放的一般都不是代码，而是一些普通文本信息，包含到.c中后一般会导致编译不通过，
			所以包含普通文本文件的意义不大。
			
				不过如果普通文本文件中的内容是能够被编译通过的话，include也是可以的。
			
			例子
					a.txt
						void fun(int a)
						{
							printf("a = %d\n", a);
						}

					
					helloworld.c
						#include "a.txt"

						int main(void)
						{
							fun(100);

							return 0;
						}
						
						查看预编译后的结果：你会发现a.txt的内容被完整的包含在了hellowolrd.c中。
						gcc helloworld.c完全没有是任何问题，./a.out也能够正常运行，打印结果为100。
						
						如果你不想a.txt的内容被重复包含的话，可以加入#indef或者#pragma once。
		
						不过我们不建议include 普通文本文件，因为这种属于非正规操作。
					
						
		5.1.2 为什么不包含其它的.c文件
				既然普通文本文件都能包含，自然包含.c文件也可以，但是包含.c文件存在一些个问题。
				
			我们都知道在.c中会定义函数，如果.c中有extern属性的函数的话，不同的.c包含了同一个.c时，
		会导致函数被重复定义，链接时就会报错。
			
			例子：
			a.c 
				static void fun(void)
				{
					...
				}
			
			b.c                                 		  c.c
 				#include "a.c"                    			#include "a.c"
				
				int main(void)                          ...
				{
					
				}
			
				编译：gcc b.c c.c 
				报错：multiple definition of `fun'，fun重复定义了
				
				就算加上#ifndef #pragma once也没用，因为它们只能防止在同一文件中多次包含a.c，但是无法防止
			在不同的.c同时包含同一个a.c。
				
				当然，我们只要使用static修饰fun，也就是将fun改为本地的（那么fun就只在本文件有效），此时倒是
			可以解决重复定义的问题，但是不管怎么说，我们不建议直接include "***.c"，因为这也不是正规操作。
				
		
	
		5.1.3 有同学经常问一个问题，可不可以将全局变量定义在.h中
		
				当然可以，但是一般只有少数情况会这么做，大多数情况都是定义在.c中，因为放在.h中的话存在一些问题。
				
		（1）如果将初始化的全局变量放在.h中的话，可能会带来大麻烦
				xxx.h 
				#ifnedf  H_XXX_H
				#define  H_XXX_H
				
				int flag = 100;
				
				
				#endif
				
				
					flag是extern修饰的，在全局都是可见的，如果这个时候a.c b.c c.c中都包含了xxx.h，这会导致每个.c中都包含了
				一个int flag = 100;，链接时就会报flag重复定义了，因为有重名的强符号。
				
				
					此时怎么办？
					可以加static修饰，比如
					xxx.h 
					#ifnedf  H_XXX_H
					#define  H_XXX_H
			
					static int flag = 100;
					
					#endif
					
					那么每个.c包含xxx.h时，每个.c中的flag就只在本文件中有效，防止了不同.c中flag的冲突，但是这样也存在问题，
					如果某个.c中碰巧也定义了一个flag，这也会导致冲突。
					a.c
					include "xxx.h"
					
					int flag = 400;
					
					
					
					展开后就变成了
					a.c
					static int flag = 100;
					
					int flag = 400;
					
					将a.c编译为a.o时，也会报错说flag冲突了，因为这两个都是强符号，显然会导致强符号的重名冲突，
					所以加static修饰也是不保险的。	
							
							
			（2）如果非要将变量放在.h中，只有出现以下描述的情况时，我们才会这么做
						
						那就是希望这个变量时“全局”可见的，能够被其它的.c引用，此时才放到.h中，而且放到.h中时不能初始化，
					只能是未初始化的弱符号，因为弱符号是允许重名的。
					
					xxx.h 
					#ifnedf  H_XXX_H
					#define  H_XXX_H
					...
					int flag;
					...
					#endif
					
					
					疑问：我就是需要给以一个初始值，怎么办呢？
					答：此时我们就需要将有初始化的强符号放在.c中，.h中还是只放未初始化的弱符号，此时这个弱符号其实就变成了
					强符号的声明。
																				
					a.c                             a.h
					                                #ifnedf  H_A_H
					int flag = 100;                 #define  H_A_H
					                                ...
																					extern int flag; //这就是int flag = 100;的声明
														              ...
																					#endif
					
					
					b.c 
					#include "a.h" //将声明extern int flag;包含到b.c中
					
					int fun(void)
					{
						flag = 1000;  //此时就可以b.c就使用flag了
					}
					
					
					所以只有出现以上情况时，我们才将未初始化的全局变量放到.h中，否则都是放在.c中。
					
					
					总结：
					· 没有特殊情况，不要全局变量放到.h中
					· 只有当你希望这个变量是全局可见的时候，才放到.h，以方便其它的.c包含
					· 放到.h中时一定不能初始化，否则可能会到带来编译麻烦
					· 如果非要初始化的，这个初始化只能放在.c中，.h中的弱符号此时就是声明
	
	
		5.1.4 <> 与 ""
		
		（1）以<>包含头文件
		
				1）如何搜寻.h
						直接到指定的“系统路径”下查找你要包含的头文件，如果找到就包含，找不到就提示头文件不存在。
				
					我们在第一章中就介绍过，通过gcc -v的详细信息就可以查看系统路径有哪些。
					演示：
					
					
					
					这些系统路径属于“原生”系统路径，也就是由编译器内定的系统路径。
					
					
				2）我们自己能不能把某个路径变成系统路径呢？
						可以，只需要给编译命令指定相应选项即可，比如以gcc为例，通过-I选项即可实现，比如：
						
						gcc -I /home/zxf/Desktop/my_include ***.c ***.c 
						
						搜寻.c中通过<>所包含的.h时，除了会到“原生”的路径下搜寻外，也会到/home/zxf/Desktop/my_include这个
					系统路径下搜寻。
						
						
						注意：指定的路径也可以是相对路径，而且-I /home/zxf/Desktop/my_include也可以放到最后面，比如：
						gcc ***.c ***.c -I /home/zxf/Desktop/my_include 
						
				
				3）例子（Linux下的例子）	
						包含自己的头文件时，就可以将.h所在的路径加入“系统路径”，如此就可以使用<>来包含自己的.h文件。
						
						· helloworld.h
								#pragma once //防止重复包含

								#define STR  "hello world"
			
							假设helloworld.h所在的路径为/home/zxf/Desktop/my_include。
						
						
						
						· helloworld.c
								#include <stdio.h>     
								#include <helloworld.h>

								int main(void)
								{
									printf("%s\n", STR);
									
									return 0;
								}
							
							
								gcc -I /home/zxf/Desktop/my_include helloworld.c
								
								
								我们这里的例子是在Linux下测试的，如果你是在Windows下测试的，这个路径就应该是windows下的路径。
								你自己去实现这个例子时，具体路径是多少，需要根据你自己的情况来定，而且也可以是相对路径。
								gcc -I ./my_include/ helloworld.c -v

								
								疑问：如果要好几个路径的话，怎么办？
								答：很简单，比如：
								gcc -I /home/zxf/Desktop/my_include  -I /home/zxf/Desktop/  helloworld.c
								
								
								通过-I选项将路径加入了系统路径后，加-v显示详细信息时，你会发现“系统路径”多了一条
							/home/zxf/Desktop/my_include。
								
								//在如下路径搜索<>所包含的头文件，
								#include <...> search starts here:
								 /******自己添加的系统路径******/
								 /home/zxf/Desktop/my_include   
								 
								 /****** 原生系统路径 *****/
								 /usr/lib/gcc/x86_64-linux-gnu/5/include
								 /usr/local/include
								 /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
								 /usr/include/x86_64-linux-gnu
								 /usr/include
					
					
				4）在IDE中如何添加“系统路径”
						前面直接使用编译器命令时，是通过“命令选项”来实现的，在IDE下也可以，只不过是图形化操作的。
						
						我们前面说过，IDE最终会调用编译器命令来编译程序，所以通过IDE所提供的图形化方式添加了系统路径后，
						IDE调用编译器命令时，这个路径会变成命令的选项，也就是说，最终还是通过选项来实现的。
						
					（a）KEIL IDE设置系统路径
							演示

							
							
							
					（b）Codeblocks IDE设置系统路径
							演示
					
					
					
					
					（c）其它的IDE
							都是类似的，这里不再啰嗦。
							
							
							
							
		（2）以""包含头文件
		
				1）如何搜寻.h
						先到程序员自己指定的路径下寻找头文件，如果找不到再到“系统路径”下寻找头文件。
						不管是在那个路径找到了.h，只要找到了就OK，其实我们通过""包含.h文件时，一般都是希望到自己所指
					定的路径下去搜寻。

						程序员自己指定的路径可以是相对路径，也可以是绝对路径。
						
					· 绝对路径
						#include "/home/zxf/Desktop/my_include/helloworld.h"   //Linux
						#include "c:\home\zxf\Desktopmy_include\helloworld.h"  //Windows
						
						先到自己指定的绝对路径下搜寻，找不到才到系统路径下搜寻。
						
					· 相对路径
						#include "./my_include/helloworld.h"  
						#include "../my_include/helloworld.h" 
						#include "./helloworld.h"  				
						
						先到相对路径下搜寻，找不到才到系统路径下搜寻。
						
						如果相对路径是从./开始的，./可以省略，因为省略后默认就是./。
						因此#include "./helloworld.h"等价于#include "helloworld.h" 
			
			
				2）绝对路径和相对路径的起点
				
				（a）绝对路径的起点
						· 在Linux下
							比如:#include "/home/zxf/Desktop/my_include/helloworld.h" 
							在Linux下，绝对路径的起点/。
						
						· 在Windows下
							比如：#include "c:\home\zxf\Desktopmy_include\helloworld.h"
							在windows下，绝对路径的起点为盘符（c:、d:）。
						
						
				（b）相对路径的起点
							以包含.h的.c所在路径为起点去搜寻.h文件，比如：

						· #include "./my_include/helloworld.h" 
								./：包含helloworld.h的helloworld.c所在的路径
							
								
						· #include "../my_include/helloworld.h" 	
								../：包含helloworld.h的helloworld.c所在路径的上一级目录
								
								
						· #include "./helloworld.h"  
								前面说过，等价于#include "helloworld.h"，其实就是直接到.c所在的路径下去找.h，找不到再到系统
							路径下找。
								
								所以当.h和.c在同一个目录下时，我们经常写都是#include "helloworld.h"这种方式。
	

	
		（3）如何包含自己的头文件
				通过前面的介绍可知，包含我们自己的头文件时，使用<>和""方式都可以。
				
				1）以<>方式包含时需要将自己.h所在路径下入系统路径
					加入系统路径的方式有两种：
					（a）直接给编译器命令指定选项
							如果我们是直接使用“编译器命令”来编译链接程序的话，就是使用这种方式。
						
					（b）通过IDE图形界面设置
							如果是使用IDE来开发的话，就使用这种方式。
				
				
				2）以""方式包含时，可以在""中直接指定.h所在的路径
					在实际上的开发中，以上这两种方式都是经常用到，只不过""方式用的可能更多一些。
					
					特别是当.c和.h就在同一个目录下时，我们经常使用的就是#include "***.h"的方式。
					
					
				3）也可以将自己的.h复制编译器内定的系统路径下，此时也可以使用<>包含
						但是一般不这么做，因为编译器内定的系统路劲，放的是系统.h文件，我们最好不要污染。
						
						
						
						
						
						